<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"piz-ewing.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="作为程序员，谁能拒绝徒手撸一个编译器呢？ 😄">
<meta property="og:type" content="article">
<meta property="og:title" content="编译器设计与实践">
<meta property="og:url" content="https://piz-ewing.github.io/2022/10/11/compiler_design_practice/index.html">
<meta property="og:site_name" content="ewing">
<meta property="og:description" content="作为程序员，谁能拒绝徒手撸一个编译器呢？ 😄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://piz-ewing.github.io/2022/10/11/compiler_design_practice/image-20221010232651279.png">
<meta property="article:published_time" content="2022-10-11T03:24:00.000Z">
<meta property="article:modified_time" content="2022-10-11T03:24:00.000Z">
<meta property="article:author" content="ewing">
<meta property="article:tag" content="compiler">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://piz-ewing.github.io/2022/10/11/compiler_design_practice/image-20221010232651279.png">


<link rel="canonical" href="https://piz-ewing.github.io/2022/10/11/compiler_design_practice/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://piz-ewing.github.io/2022/10/11/compiler_design_practice/","path":"2022/10/11/compiler_design_practice/","title":"编译器设计与实践"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编译器设计与实践 | ewing</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ewing</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-explorer"><a href="/explorer/" rel="section"><i class="fa fa-binoculars fa-fw"></i>浏览</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-number">2.</span> <span class="nav-text">总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text">架构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">内存分配系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">符号系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">类型系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.</span> <span class="nav-text">日志系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">词法分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">语法分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">10.</span> <span class="nav-text">语义分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IR-%E7%94%9F%E6%88%90"><span class="nav-number">11.</span> <span class="nav-text">IR 生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0"><span class="nav-number">11.1.</span> <span class="nav-text">常量折叠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BA%A6%E6%B6%88%E5%BC%B1"><span class="nav-number">11.2.</span> <span class="nav-text">强度消弱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E6%95%B0%E7%AE%80%E5%8C%96%E5%92%8C%E9%87%8D%E7%BB%93%E5%90%88"><span class="nav-number">11.3.</span> <span class="nav-text">代数简化和重结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%BC%96%E5%8F%B7"><span class="nav-number">11.4.</span> <span class="nav-text">值编号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">优化器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96"><span class="nav-number">12.1.</span> <span class="nav-text">窥孔优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%B6%88%E9%99%A4"><span class="nav-number">12.2.</span> <span class="nav-text">变量消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%B6%88%E9%99%A4"><span class="nav-number">12.3.</span> <span class="nav-text">跳转消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%9F%BA%E6%9C%AC%E5%9D%97"><span class="nav-number">12.4.</span> <span class="nav-text">合并基本块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E7%A0%81%E6%B6%88%E9%99%A4"><span class="nav-number">12.5.</span> <span class="nav-text">死码消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">13.</span> <span class="nav-text">代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D"><span class="nav-number">13.1.</span> <span class="nav-text">寄存器分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6"><span class="nav-number">13.2.</span> <span class="nav-text">指令调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">14.</span> <span class="nav-text">虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%88%E8%BF%98%E6%98%AF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">14.1.</span> <span class="nav-text">基于栈还是寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA"><span class="nav-number">14.2.</span> <span class="nav-text">类型表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%A4%E4%BA%92"><span class="nav-number">14.3.</span> <span class="nav-text">虚拟机交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">解析交互模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">16.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A2%8E%E8%AF%AD"><span class="nav-number">17.</span> <span class="nav-text">碎语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">18.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ewing"
      src="https://avatars.githubusercontent.com/u/78925867?v=4">
  <p class="site-author-name" itemprop="name">ewing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/piz-ewing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;piz-ewing" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:piz.ewing@gmail.com" title="E-Mail → mailto:piz.ewing@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://piz-ewing.github.io/2022/10/11/compiler_design_practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/78925867?v=4">
      <meta itemprop="name" content="ewing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ewing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编译器设计与实践 | ewing">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译器设计与实践
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-11 03:24:00" itemprop="dateCreated datePublished" datetime="2022-10-11T03:24:00+00:00">2022-10-11</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr>
<p><strong>作为程序员，谁能拒绝徒手撸一个编译器呢？</strong> 😄</p>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近段时间一直在做《从0开始的编译器实现》，也算是趟了一遍坑。<br>遂撰文记录一下，希望能给有想法接触这方面的人提供一点帮助。</p>
<blockquote>
<p><em>Q: 有人曾问我，做这种东西有什么意义，直接去学 <code>llvm</code>，搞搞 <code>flex</code> <code>bison</code> <code>yacc</code> 它不香吗？</em></p>
</blockquote>
<blockquote>
<p><em>A: 我想了很多，不知如何回答，也许仅仅是有趣🤔？</em></p>
</blockquote>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>教学用编译器往往经过精心的简化，从而将其中一些复杂隐藏起来，<br>而一个可用的编译器则需要考虑很多的因素，复杂度也会指数上升。</p>
<p>本文将结合一些小型c语言编译器来聊这个话题，<br>参考了诸如 <code>8cc</code> <code>9cc</code> <code>chibicc</code> <code>picoc</code>  <code>ucc</code> 等。</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>通常来说，编译器会明确的分为前端、优化器、后端三个部分。</p>
<img src="/2022/10/11/compiler_design_practice/image-20221010232651279.png" class="" alt="image-20221010232651279">

<p>就实践经验来看，这三大部分实际上相当耦合。如果一开始就考虑了这种分层的设计，则后续编码过程中必将产生大量冗余和性能上的考量。<br>除非是有很大的精力，否则不推荐在自研编译器中使用<strong>分层的编码方式</strong>，这部分的取舍会相当困难。</p>
<p>一个源文件到目标程序的大致流程如下：</p>
<ol>
<li>初始化编译器上下文环境</li>
<li>读取源文件</li>
<li>通过词法分析器提取词素</li>
<li>通过语法分析器辨别语法上的正确性，构造语法树</li>
<li>通过语义分析器辨别语法树语义合理性，提炼符号信息(偏移或对齐等)</li>
<li>通过语法树构造 <code>IR(SSA)</code> 及 <code>CFG</code>（常量折叠，值编号，强度消弱，代数简化和重结合等）</li>
<li>基于 <code>IR</code> <code>CFG</code> 的优化（窥孔优化，代码消除，跳转优化等）</li>
<li>目标代码生成</li>
<li>目标程序生成</li>
<li>释放编译器上下文</li>
</ol>
<p>这里面又实际上隐含了几大必要的系统，内存分配系统，符号系统，类型系统，日志系统。</p>
<h2 id="内存分配系统"><a href="#内存分配系统" class="headerlink" title="内存分配系统"></a>内存分配系统</h2><p>一个有益的内存分配系统当然是能自行管理生命周期并防止内存无限膨胀。<br>这在编译器设计中是极其困难的，<br>除非在设计初期就能充分知道各个结构体的实现细节，既每一个结构体在何时消费掉。<br>由于结构体内部的信息本身错综复杂，若简单的采用实时释放策略，<br>会不可避免的产生大量的拷贝。</p>
<p>举例说明：<br>在获取到某个 <code>token</code> 后，通常只有部分信息(常量信息，位置信息等)对语法树的构造提供帮助，<br>如果是一个实时释放的内存系统，通过拷贝这部分有效信息可以减小内存开销。</p>
<p>而如若将宏这类预处理信息作为词法的一部分，则还需要记录对应的宏所对应的 <code>token</code> 流。<br>另外，在一些复杂的语言中，也有前看多个 <code>token</code> 的需求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	Foo(Self) &#123;</span><br><span class="line">		Self = new(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line">		Self-&gt;x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Self;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		Bar(Self) &#123;</span><br><span class="line">			<span class="comment">// .....</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">	Foo.Bar *p = Foo.Bar.Bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上述情况简记为 <code>S.S</code> 与 <code>S.S.F</code>，在这类场景中，为了获知 <code>S.S</code> 是否会成为 <code>S.S.F</code> 需要不断的前看。<br>最终它们会分别走向<code>声明</code>和<code>函数调用</code>流程。<br>当然，上述问题也能通过改善语法来解决，问题也会简化成<code>空间与时间</code>的取舍。</p>
<p>回到内存池的话题，如果仅使用<code>freelist</code>这类池来处理，<br>会不可避免的遇到预分配大小与空间浪费的问题。<br>所以采取一种混合式的池将会是自研编译器时的首要目标。<br>既要满足 <code>动态向量</code> <code>动态字符串</code> 等数据结构，又要满足一些<code>常驻信息</code>。</p>
<p>在实践中，我使用了一种类 <code>Stack-based Allocators</code> 分配策略实现一级分配器，<br>而后在其上构建出<code>freelist</code>的二级分配器。<br>当然，这并非最佳策略，只是实践上的妥协。</p>
<h2 id="符号系统"><a href="#符号系统" class="headerlink" title="符号系统"></a>符号系统</h2><p>通常来说，符号系统是为每个标识符附加一定的属性信息，<br>包括有类型信息，符号自身的作用域信息，不可写或静态等。</p>
<p>当某个符号是成员或参数时，则还需要知道该符号对应的成员或参数的信息，<br>包括了位域或偏移等。</p>
<p><code>ucc</code> 实现中，在转换阶段，符号还将作为 <code>IR</code> 的一部分存在，<br><code>tmp</code>(SSA 的临时名) 和 <code>const</code> 都会成为符号的一种。</p>
<p>函数名，记录名(结构体，联合体)，类型别名，是否都存在于同一个符号表取决于语言本身的设计。<br>例如 c 语言中，记录名是独立的符号名，而 类型别名 与 变量名 位于同一符号表中。</p>
<p>一个典型的符号结构设计如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">symbol</span> &#123;</span></span><br><span class="line">Token id; <span class="comment">// 符号名</span></span><br><span class="line">Type ty; <span class="comment">// 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ref; <span class="comment">// 被引用次数</span></span><br><span class="line"><span class="type">int</span> is_const;  <span class="comment">// 是否是常量</span></span><br><span class="line"><span class="type">int</span> is_static; <span class="comment">// 是否是静态</span></span><br><span class="line"><span class="type">int</span> is_type;   <span class="comment">// 是否是类型</span></span><br><span class="line"><span class="type">int</span> is_def;    <span class="comment">// 是否被定义</span></span><br><span class="line"></span><br><span class="line">Scope in_scope; <span class="comment">// 所在作用域</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">int</span> va_off; <span class="comment">// 全局偏移或栈偏移</span></span><br><span class="line"><span class="type">int</span> pc_off; <span class="comment">// 函数的指令偏移</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">Enum e;</span><br><span class="line">Field f;</span><br><span class="line">Param p;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>类型系统想要尽可能的包含 <code>2^n</code> 长度的数据。</p>
<p>通常会有如下基础类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空类型</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类型</span></span><br><span class="line">any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数类型</span></span><br><span class="line">i8 i16 i32 i64 isz u8 u16 u32 u64 usz</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实数类型</span></span><br><span class="line">f32 f64</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型</span></span><br><span class="line">ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">union</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 枚举类型</span></span><br><span class="line"><span class="class"><span class="title">enum</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 函数类型</span></span><br><span class="line"><span class="class"><span class="title">fn</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 标签类型</span></span><br><span class="line"><span class="class"><span class="title">label</span></span></span><br></pre></td></tr></table></figure>
<p>其中每种类型都有一个大小，代表其占用的字节数，<code>fn</code> <code>void</code> 通常为1，这是为了便于做指针的数学运算。</p>
<p>默认类型，在现有语言中通常会被设计为 <code>i32</code>，一个32位长度的有符号类型。<br>对于弱类型系统来说，比较的典型的 <code>lua</code> 则会将所有数据置于一个 <code>double</code> 中。</p>
<p>c语言的类型系统背负了历史包袱，其本身就比较复杂，<br>主要体现在 <code>unsigned</code>、<code>long</code> 关键字及函数、数组等方面，<br>对于语法分析来说，它们并不友好。</p>
<p>就函数来说，若不涉及指针相关问题，<br>使用诸如 <code>rust</code> 或 <code>golang</code>流的 <code>fn</code> 关键字会更加优雅。</p>
<p>作为c语言灵魂的指针，如果使用了 <code>fn</code> 关键字，则会引入其它方面的不便利。</p>
<p>在c语言中，指针数组，函数指针，函数指针数组…，解析起来相对复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">T id;</span><br><span class="line">T (*(*id));</span><br><span class="line">T (*id)[];</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T, T)</span>;</span><br><span class="line">T (*id)(T, T);</span><br><span class="line">T (*id[])(T, T);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>而函数的声明和定义则更进一步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">id</span><span class="params">(T, T)</span>;</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T id, T id)</span>;</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T id, T id)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你必须在完整解析整个声明部分之后才能确定主 <code>id</code> 到底是什么类型。</p>
<p>以上仅是冰山一角，接下来，还会面对另一个严肃的问题，类型兼容与类型转换。</p>
<p>很多情况下，编译器都需要判断出两个类型是否兼容，或者是否合理。</p>
<p>对于c语言这种不纯粹的强类型语言来说，隐式类型转换会发生的更加频繁。<br>这是一个让人又爱又恨的机制，它很容易让人犯错，但也很方便，<br>没有人希望顶着一堆类型转换写完代码，除非你压根不知道自己在写什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">1.0f</span>;</span><br><span class="line"><span class="number">2</span> + (<span class="type">int</span>*)<span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在进行表达式语义分析时，编译器作者不得不一遍又一遍的比较左右子树的类型，为其添加对应的转换过程。<br>同时这个转换过程还会受到一些限制，比如 <code>+-</code> 的两边不能都是指针，但其中一边可以是指针，<br>位运算则要求必须是整数，逻辑运算则要求两边都是可计算的类型等等。</p>
<p>除此之外，类型系统还有另一个复杂点，函数名，数组名，标签名在表达式中会退化为一种特别的指针类型。<br>例如对函数名取值、取地址操作得到的依旧函数本身的偏移值，即源函数指针。<br>而对数组名取值会取到一个元素。标签名则不允许取值操作，同样也不应参与运算。<br>对于<code>gcc</code> 这种 <code>label as value</code> 的机制则需要更多的处理。</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>日志系统从表面上看，只是一个用于打印输出的模块，但实际的内容会比一眼看上去的多。</p>
<p>首先一个好的编译器日志系统不仅要能辅助编译器实现，即报出编译器自身的异常信息和调试信息，同时也应用于输出编译过程中的警告错误等。</p>
<p>一个典型的编译错误日志如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a b</span><br><span class="line">------^</span><br><span class="line"></span><br><span class="line">[main.c:<span class="number">1</span>] error: expect <span class="string">&#x27;;&#x27;</span> but got <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于编译自身日志，可以和普通的打印一致，立即输出到屏幕，而对于编译日志则需要更多的工作。<br>一方面，需要打印错误的代码位置，方便语言使用者定位问题。<br>另一方面，还需要考虑到错误恢复机制带来的影响，即不是所有的 <code>err</code> 日志都能立即退出。<br>如果编译器本身被嵌入了复杂的系统环境中，则不一定支持立即退出这种一劳永逸的办法，而是应该在统一的出口处报错。</p>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>纯手写词法分析器并不困难，值得注意的只有以下几点：</p>
<ol>
<li>常量字面量类型处理</li>
<li>转义字符</li>
<li>保留字识别</li>
<li>ch 前看支持</li>
<li>token 前看支持</li>
</ol>
<ul>
<li><p><strong>常量字面量</strong> 存在有前后缀问题，需要注意。且对于<code>??.??.??</code> 或 <code>0x??.??</code> 也需要进一步处理。</p>
</li>
<li><p><strong>转义字符</strong> 需要获取转义值。</p>
</li>
<li><p><strong>保留字</strong> 则和标识符的处理逻辑共用，通常是获取标识符后，判断该标识符是否是保留字。</p>
</li>
<li><p><strong>ch 前看支持</strong> 在解析诸如 <code>++</code> <code>+=</code> <code>\n</code> …。</p>
</li>
<li><p><strong>token 前看支持</strong>：<br>c语言语法中强制类型转换是较为特别的存在，<br><code>(T)</code> 或 <code>(id)</code> ，<br>对比上述两者，前者为强制类型转换，<br>后者则是普通的表达式主语。<br>故为了识别出具体是哪种，需要前看支持。<br>在支持 <code>S.S.F</code> 的编译器中，这一问题会变得更为复杂，例如 <code>c++</code> 的静态成员函数等。</p>
</li>
</ul>
<p>编译器设计初期就应为上述问题提供一个合理的方案，包含但不局限于此。</p>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>自研编译器中，可以把语法分析和语义分析放到一个趟中处理。</p>
<p>语法分析器只表明语法上是否合规，基本是一套固定的逻辑。<br>通常会采用<code>递归下降的语法分析器</code>，也有像 <code>c4</code> 那种特别定制的分析器。</p>
<p>这一部分可以直接对照语法实现，在各类编译器书籍中出现较多。</p>
<p>对于c语言来说，最复杂的部分是 <code>ExternalDeclaration</code>，其中牵扯声明定义，导出静态，常量…需要尤其注意。</p>
<p>另外在关于 <code>Ast_Node</code> 结构的选型上，不同编译器采用了不同的形式。<br>例如 <code>ucc</code> 中会为不同的语句等设计独立的 <code>node</code> 结构，将所有的<code>二元``一元</code>规整到一起设计一个通用结构。<br>在 <code>chibicc</code> 中，则全部使用一个通用结构，其内部可以用联合体优化。</p>
<p>二者只能说各有千秋，前者的问题在于需要更多的强制类型转换才能将所有的节点串到一起，<br>后者的问题则是编写过程中很容易搞混。</p>
<p>如果语法分析和语义分析器是独立的，则在处理<code>初始化列表</code>时会增加一定难度。</p>
<p>如果二者是融合的，则以常量表达式及常量折叠入手编写会更加容易。<br>当然，融合实现时，代码也会更加复杂，</p>
<h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>自研编译器中，若采用独立的语义分析器，则语法分析部分不考虑语义问题。</p>
<p>语义分析阶段，除去检查符号重定义或类型声明及语句的合法性外，还应检查类型是否兼容等问题。</p>
<p>该阶段要为每一个表达式的节点确定类型，同时还需要确定其是否是左值，是否可写，是否为常量等等。</p>
<p>符号表的建立也会发生在该阶段，<br>需要特别注意的是，在部分情况下(函数声明时的参数检查，<code>record</code>类型的成员检查)，符号只应检查是否在当前作用域发生重定义。</p>
<p>变量的偏移值可以在其定义时获取，没有初始化定义的变量都可以被简化成一个偏移值，即可消除掉对应的节点 。</p>
<p>初始化列表是否匹配也发生在该阶段，需要处理各种可能的情景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[][2] = &#123;&#123;1,2&#125;, 2, 3, 4, &#123;5,6&#125;&#125;;</span><br><span class="line">int b = &#123;&#123;0&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果涉及 <code>goto</code>，按照 <code>clang</code> 的结论是会重复执行初始化赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__foo:</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> __foo;</span><br></pre></td></tr></table></figure>

<p>对于位域问题和匿名 <code>record</code> 内嵌问题，对齐问题，也都需要一一处理。</p>
<p>例如位域是否应该采取紧凑型，又或者是否应该支持 <code>int:31</code> 这类场景，还有一些不能对位域取地址限制的检查。</p>
<p>大部分常量折叠也会发生在这一阶段。</p>
<p>例如 <code>int a[1+1]</code> ，<code>1+1</code> 需要被折叠以确定 <code>[]</code> 中是一个大于等于零的整数。<br>同时常量指针也应参与折叠过程 <code>0+(void*)0</code>。</p>
<h2 id="IR-生成"><a href="#IR-生成" class="headerlink" title="IR 生成"></a>IR 生成</h2><p>SSA IR 是一种比起语法树更简洁的表现形式，在其基础上优化会更容易。<br>同时生成过程中也可以完成一些前期优化工作，收集必要信息，构造控制流图等。</p>
<h3 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h3><p>在逻辑与算法生成短路现象时，会将 <code>&amp;&amp;</code> 的左右拆开，生成条件跳转，这会在原来的节点上填充新的算术节点。<br>对于会填充新算术节点的情况就需要再次进行常量折叠。</p>
<h3 id="强度消弱"><a href="#强度消弱" class="headerlink" title="强度消弱"></a>强度消弱</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = i * 7</span><br><span class="line">-&gt;</span><br><span class="line">t = i &lt;&lt; 3</span><br><span class="line">t = t - i</span><br></pre></td></tr></table></figure>

<h3 id="代数简化和重结合"><a href="#代数简化和重结合" class="headerlink" title="代数简化和重结合"></a>代数简化和重结合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a*1 = a</span><br><span class="line">a/1 = a</span><br><span class="line">a+0 = a</span><br><span class="line">a-0 = a</span><br><span class="line">-(-a) = a</span><br><span class="line">i + (-a) = i-a</span><br><span class="line">*(&amp;p) = p</span><br><span class="line">(&amp;q)-&gt;s = q.s</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="值编号"><a href="#值编号" class="headerlink" title="值编号"></a>值编号</h3><p>值编号是判断两个计算是否等价并删除其中之一的一种办法。<br>为 op src dst 计算一个hash，判断该计算是否已经生成变量 t，<br>判断 t 是否位于当前基本块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int b,x;</span><br><span class="line">//</span><br><span class="line">int a = b + 1;</span><br><span class="line">int c = b + 1 + x;</span><br><span class="line"></span><br><span class="line">IR:</span><br><span class="line">t0 = b + 1</span><br><span class="line">a = b</span><br><span class="line">t1 = t0 + x  ; 这里就发生了简化，不再生成 b+1 的计算</span><br><span class="line">c = t1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 src dst 发生改变时，其对应的值编号将不能再被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b = b + 1;</span><br><span class="line">int c = b + 1 + x</span><br><span class="line"></span><br><span class="line">IR:</span><br><span class="line">t0 = b + 1</span><br><span class="line">b = t0</span><br><span class="line">t1 = b + 1    ; 不能简化</span><br><span class="line">t2 = t1 + 1</span><br><span class="line">c = t2</span><br></pre></td></tr></table></figure>

<p><strong>限于篇幅，本文只举出几个简单的例子，后面有机会再摊开说明</strong>。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><h3 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 移除无用的 MOV</span><br><span class="line">CALL t0 foo (...)</span><br><span class="line">MOV  a, t0</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">CALL a foo (...)</span><br><span class="line"></span><br><span class="line">// 移除无用的 MOV</span><br><span class="line">ADD t0 &lt;- b 1</span><br><span class="line">MOV b  &lt;- t0</span><br><span class="line">--&gt;</span><br><span class="line">ADD b &lt;- b 1</span><br><span class="line"></span><br><span class="line">// 优化指令</span><br><span class="line">ADD b &lt;- b 1</span><br><span class="line">-&gt;</span><br><span class="line">INC b</span><br></pre></td></tr></table></figure>

<p>窥孔优化即根据几条相邻的指令内容简化指令，除了基于 IR 的优化外，还可以在代码生成阶段，根据目标平台指令，进一步优化。</p>
<h3 id="变量消除"><a href="#变量消除" class="headerlink" title="变量消除"></a>变量消除</h3><p>移除未引用的临时变量</p>
<h3 id="跳转消除"><a href="#跳转消除" class="headerlink" title="跳转消除"></a>跳转消除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jmp lab0</span><br><span class="line"></span><br><span class="line">lab0:</span><br><span class="line">jmp lab1</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">jmp lab1</span><br></pre></td></tr></table></figure>

<h3 id="合并基本块"><a href="#合并基本块" class="headerlink" title="合并基本块"></a>合并基本块</h3><p>移除没有指令的基本块或将跳转消除后的基本块合并。</p>
<h3 id="死码消除"><a href="#死码消除" class="headerlink" title="死码消除"></a>死码消除</h3><p>遍历控制流图，仅保留可达的基本块。</p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h3><p>将无限的虚拟寄存器映射到有限的真实寄存器的过程。<br>一种常用的方案是图着色分配方法，由 构造、简化、溢出、选择 四个主要阶段构成。<br>在 《高级编译器设计与实现》《现代编译原理：c语言描述》等书中有细致的描述。</p>
<p><strong>后面有时间再单独结合代码聊一下这个</strong>。</p>
<h3 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h3><p>略，这个我还没搞明白，自研编译器鲜有实现到这里的。<br>大概意思是调度重排指令，使其能更好利用目标处理器的流水线。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="基于栈还是寄存器"><a href="#基于栈还是寄存器" class="headerlink" title="基于栈还是寄存器"></a>基于栈还是寄存器</h3><p>对于虚拟机本身来说二者区别实际上不大。<br>对于编译器来说，更容易生成高质量的寄存器虚拟机指令。</p>
<p>栈式虚拟机在栈上产生的值需要额外的弹出操作，<br>虽然也可以优化，但我了解不多。</p>
<h3 id="类型表示"><a href="#类型表示" class="headerlink" title="类型表示"></a>类型表示</h3><p>虚拟机在计算时，仍旧需要关注类型及类型转换。<br>有符号与无符号，实数与整数等运算都有涉及。</p>
<h3 id="虚拟机交互"><a href="#虚拟机交互" class="headerlink" title="虚拟机交互"></a>虚拟机交互</h3><p>虚拟机应提供中止或打断的介入能力，以用于监视其执行过程。<br>同时也应该能有效的调用外部函数，拥有类似 <code>dyncall</code> <code>libffi</code> 的功能。<br>当虚拟机内部函数被作为回调函数传送到外部时，应使用某种识别机制以包装该函数。<br>多线程情况下的资源协调与同步问题。</p>
<h2 id="解析交互模式"><a href="#解析交互模式" class="headerlink" title="解析交互模式"></a>解析交互模式</h2><p>开始确实有引入交互模式的想法，但是后来发现错误回滚方面有着<strong>巨大的代价</strong>，同时不能很好的融入编译模式。<br><code>picoc</code> 在这方面提供了很好的参考，虽然它也未能很好的解决错误回滚问题，也许需要一个更好的内存分配系统和一个更好的内存快照机制才能解决。</p>
<p>综上，实现的价值太低，代价又太大，遂放弃。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合我数月的实践经验，简单聊了一下自研编译器时会遇到各种问题。<br>文中很多地方没有使用规范的术语，而且只是从实践的角度进行片面的描述。<br><strong>实践并不代表符合编译器设计的各种规范</strong>。</p>
<p>从 <code>8cc</code> 到 <code>9cc</code> 再到 <code>chibicc</code>，可以看到作者的一路征程。<br>同样的 <code>ucc</code> 是我认为写的比较完善的小型c编译器之一了，<br>其中也存在着很多的 <code>bug</code>。<br>一个完善的c编译器，只能说非常难。<br>可以想象 <code>c++</code> 编译器得复杂到何种程度。</p>
<p>文中还有很多很多没有写到的地方，比如类型推导之类。<br>回过头再看，其实有很多更好的实践方案。很多地方都是时间上的妥协。</p>
<h2 id="碎语"><a href="#碎语" class="headerlink" title="碎语"></a>碎语</h2><p>这几个月，前后推翻重写了6，7次，才写出一个相对可用的框架。<br>目前也才实现到了<code>IR 生成</code>一小部分。</p>
<p>总之，钱烧完了，得去找工作了😄。<br>之后也会持续更新本文，为实现一个真正可用的编译器而努力💪。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc">GitHub - rui314&#x2F;chibicc: A small C compiler</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/8cc">GitHub - rui314&#x2F;8cc: A Small C Compiler</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/9cc">GitHub - rui314&#x2F;9cc: A Small C Compiler</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nobled/ucc">GitHub - nobled&#x2F;ucc: ucc - a tiny C89 compiler for x86</a></li>
<li><a target="_blank" rel="noopener" href="https://gitlab.com/zsaleeba/picoc">Zik Saleeba &#x2F; picoc · GitLab</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/compiler/" rel="tag"># compiler</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/30/ishot_crack/" rel="prev" title="ishot_crack -- OSX M1(Apple Sillcon) 逆向工程实践">
                  <i class="fa fa-angle-left"></i> ishot_crack -- OSX M1(Apple Sillcon) 逆向工程实践
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/19/socks5/" rel="next" title="SOCKS5 代理?">
                  SOCKS5 代理? <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ewing</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">35k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:06</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"piz-ewing/piz-ewing.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
