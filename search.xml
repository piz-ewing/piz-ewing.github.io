<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dash_crack -- OSX M1(Apple Sillcon) 逆向工程实践</title>
    <url>/2021/08/24/Dash_crack/</url>
    <content><![CDATA[<h2 id="坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。"><a href="#坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。" class="headerlink" title="坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。"></a><strong>坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。</strong></h2><span id="more"></span>

<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在 <code>osx</code> 上找文档工具，想起之前在 <code>linux</code> 上用过一款名为 <code>Zeal</code> 的开源软件，顺藤摸瓜下载了 <code>Dash</code>，使用体验还不错。</p>
<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><ul>
<li>macOS Big Sur 11.5.2 (M1)</li>
<li>Dash 6.0.7 (980)</li>
<li>IDA Pro (7.6)</li>
</ul>
<h2 id="定位激活函数"><a href="#定位激活函数" class="headerlink" title="定位激活函数"></a>定位激活函数</h2><ol>
<li><p>打开软件尝试注册，发现扩展名未知。根据提示说明可以双击证书文件激活，故可以根据 <code>info.plist</code> 的文件关联信息获取到证书的后缀名为 <code>dash-license</code>.</p>
<img src="/2021/08/24/Dash_crack/0.png" class="" alt="获取后缀">
</li>
<li><p>构建一空白文件，再次尝试，提示 <code>The license file does not seem to be valid.</code></p>
</li>
<li><p>在应用目录下找到 <code>Dash</code> 二进制文件，拖入 <code>IDA Pro</code>，查找错误提示。</p>
</li>
</ol>
<img src="/2021/08/24/Dash_crack/1.png" class="" alt="错误提示">

<ol start="4">
<li>通过查找交叉引用，定位到成员函数 <code>-[DHInApp processLicenseFile:]</code></li>
</ol>
<img src="/2021/08/24/Dash_crack/2.png" class="" alt="定位目标函数">

<ol start="5">
<li>速览目标函数，其内部的字符串信息表明该函数与激活存在直接关系。</li>
</ol>
<img src="/2021/08/24/Dash_crack/3.png" class="" alt="确定激活函数">

<p>由于 <code>Dash</code> 是一个通用二进制文件(即包含 <code>arm</code>，<code>x86_64</code>)。 使用 <code>x86_64</code> 的反编译结果通常优于 <code>arm</code> 的结果。 <code>hopper</code> 分析同理。</p>
<p><strong>如非必要，在静态分析阶段应优先考虑分析 <code>x86_64</code> 格式。</strong></p>
<h2 id="逐层分析"><a href="#逐层分析" class="headerlink" title="逐层分析"></a>逐层分析</h2><p>通过 <code>IDA pro</code> 的反编译，整理出如下伪代码，仅包含需要关注的部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> DHInApp::displayString() == <span class="string">&quot;com.barebones.textwrangler&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> ok_msg(<span class="string">&quot;The full version of Dash is already active. Thank you!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> Not fileExistsAtPath(<span class="string">&#x27;~/Library/Application Support/Dash/License/license.dash-license&#x27;</span>):</span><br><span class="line">    cleanDir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 拷贝文件</span></span><br><span class="line"><span class="keyword">if</span> Not CopyFile(curLicense, <span class="string">&#x27;~/Library/Application Support/Dash/License/&#x27;</span>):</span><br><span class="line">    <span class="keyword">return</span> err_msg(<span class="string">&quot;Dash was not able to save your license. This most likely means that you don&#x27;t have write permissions in ~/Library/Application Support/Dash/License. Try to delete ~/Library/Application Support/Dash/License and try again.\n\nThe error was: %@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重新校验</span></span><br><span class="line">DHInApp::setThirdB(<span class="number">0L</span>)</span><br><span class="line">DHInApp::setLoadingString(<span class="number">0L</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DHInApp::displayString() != <span class="string">&quot;com.barebones.textwrangler&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> DHInApp::upgradeAvailable():</span><br><span class="line">        <span class="keyword">return</span> err_msg(<span class="string">&quot;This license is for Dash %ld. You need to upgrade it before you can use it with Dash 6.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> err_msg(<span class="string">&quot;The license file does not seem to be valid. Sorry! Please contact the developer if you need help.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空校验信息</span></span><br><span class="line">DHInApp::transactionFailed()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 显示成功动画</span></span><br><span class="line">displayViewForIdentifier::animate(<span class="string">&quot;Purchase&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 更新校验信息</span></span><br><span class="line">CFDictionaryRef_sub_100058844(<span class="string">&#x27;~/Library/Application Support/Dash/License/license.dash-license&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上是经过整理的结果。</p>
<p>以上需要重点关注的部分有两个，</p>
<ul>
<li><code>DHInApp::displayString</code></li>
<li><code>CFDictionaryRef_sub_100058844</code></li>
</ul>
<p>并不能简单的让 <code>DHInApp::displayString</code> 返回正确的字符串，而是需要它走到下面的更新校验信息部分。</p>
<img src="/2021/08/24/Dash_crack/4.png" class="" alt="注册信息">

<p>图中的 <code>verifier_and_loadDataFromXML</code> 是 <code>CFDictionaryRef_sub_100058844</code> 在分析完功能后重命名的结果。</p>
<hr>
<p><strong>以下反编译结果均出自 <code>IDA Pro</code>。</strong></p>
<p><strong>为了方便阅读，下文代码结果均经过重命名处理，并用 <code>// ....</code> 的形式省略无用代码。</strong></p>
<hr>
<h2 id="深入-DHInApp-displayString"><a href="#深入-DHInApp-displayString" class="headerlink" title="深入 DHInApp::displayString"></a>深入 <code>DHInApp::displayString</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id __cdecl -[DHInApp displayString](DHInApp *self, SEL a2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line">  v2 = -[DHInApp loadingString](self, <span class="string">&quot;loadingString&quot;</span>);<span class="comment">// 如果没有文件，这里第一次会返回空字符串，第二次会被设置</span></span><br><span class="line">  <span class="keyword">if</span> ( objc_msgSend(v2, <span class="string">&quot;length&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> -[DHInApp loadingString](self, <span class="string">&quot;loadingString&quot;</span>);</span><br><span class="line">  v4 = -[DHInApp thirdB](self, <span class="string">&quot;thirdB&quot;</span>); <span class="comment">// 第一次进，这里是fail，第二次会被设置</span></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)objc_msgSend(v4, <span class="string">&quot;isEqualToString:&quot;</span>, CFSTR(<span class="string">&quot;fail&quot;</span>)) )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// .....</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = objc_msgSend(&amp;OBJC_CLASS___NSFileManager, <span class="string">&quot;defaultManager&quot;</span>);</span><br><span class="line">  v7 = +[DHInApp licenseFile](&amp;OBJC_CLASS___DHInApp, <span class="string">&quot;licenseFile&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> __int8)objc_msgSend(v6, <span class="string">&quot;fileExistsAtPath:&quot;</span>, v7) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  v8 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, <span class="string">&quot;mainBundle&quot;</span>);</span><br><span class="line">  v9 = (__CFString *)objc_msgSend(v8, <span class="string">&quot;pathForResource:ofType:&quot;</span>, CFSTR(<span class="string">&quot;invalidTest&quot;</span>), &amp;value);</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    v9 = &amp;value;</span><br><span class="line">  <span class="keyword">if</span> ( base64_pubkey )</span><br><span class="line">  &#123;</span><br><span class="line">    CFStringInsert(base64_pubkey, <span class="number">0LL</span>, CFSTR(<span class="string">&quot;0xAD97B0E07F8C747E2D2&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;36DC1AB0B328ABE4F2E42E4D95AEB2&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, &amp;value);</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;7AF4B41F4D84B0C70248A78E6497&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;483&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;9A95EC0652DA58BAEC965C106&quot;</span>));</span><br><span class="line">    CFStringAppend(base64_pubkey, CFSTR(<span class="string">&quot;CC3B67DD3D0694CB05&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> ( base64_pubkey )</span><br><span class="line">    &#123;</span><br><span class="line">      create_global_pubkey(base64_pubkey);</span><br><span class="line">      CFRelease(base64_pubkey);</span><br><span class="line">      base64_pubkey = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkurl_and_anti_crack(<span class="number">0LL</span>) )<span class="comment">// 这里是防破解，我们需要返回假</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  v10 = (<span class="type">const</span> __CFURL *)objc_msgSend(&amp;OBJC_CLASS___NSURL, <span class="string">&quot;fileURLWithPath:&quot;</span>, v9); <span class="comment">// 这里使用了无效文件进行检验破解</span></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkurl_and_anti_crack(v10) )<span class="comment">// 同上，这里也需要返回假</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkurl_and_anti_crack(<span class="number">0LL</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  v12 = +[DHInApp licenseFile](&amp;OBJC_CLASS___DHInApp, <span class="string">&quot;licenseFile&quot;</span>);</span><br><span class="line">  v13 = (<span class="type">const</span> __CFURL *)objc_msgSend(&amp;OBJC_CLASS___NSURL, <span class="string">&quot;fileURLWithPath:&quot;</span>, v12);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> __int8)checkurl_and_anti_crack(v13) )<span class="comment">// 真正的证书文件，这里需要返回真</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)checkurl_and_anti_crack(<span class="number">0LL</span>) )<span class="comment">// 同上，返回假</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  -[DHInApp setUpgradeAvailable:](self, <span class="string">&quot;setUpgradeAvailable:&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  v14 = +[DHInApp licenseFile](&amp;OBJC_CLASS___DHInApp, <span class="string">&quot;licenseFile&quot;</span>);</span><br><span class="line">  v15 = (<span class="type">const</span> __CFURL *)objc_msgSend(&amp;OBJC_CLASS___NSURL, <span class="string">&quot;fileURLWithPath:&quot;</span>, v14);</span><br><span class="line">  DataFromXML = verifier_and_loadDataFromXML(v15);</span><br><span class="line">  v31 = objc_autorelease(DataFromXML);</span><br><span class="line">  v17 = objc_msgSend(v31, <span class="string">&quot;objectForKeyedSubscript:&quot;</span>, CFSTR(<span class="string">&quot;Signature&quot;</span>));</span><br><span class="line">  v18 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, <span class="string">&quot;mainBundle&quot;</span>);</span><br><span class="line">  v19 = objc_msgSend(v18, <span class="string">&quot;resourcePath&quot;</span>);</span><br><span class="line">  v20 = objc_msgSend(v19, <span class="string">&quot;stringByAppendingPathComponent:&quot;</span>, CFSTR(<span class="string">&quot;BlockedLicenses.plist&quot;</span>));</span><br><span class="line">  v21 = objc_msgSend(&amp;OBJC_CLASS___NSDictionary, <span class="string">&quot;dictionaryWithContentsOfFile:&quot;</span>, v20);</span><br><span class="line">  <span class="keyword">if</span> ( v17 )</span><br><span class="line">  &#123;</span><br><span class="line">    v22 = objc_msgSend(v21, <span class="string">&quot;objectForKeyedSubscript:&quot;</span>, CFSTR(<span class="string">&quot;licenses&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)objc_msgSend(v22, <span class="string">&quot;containsObject:&quot;</span>, v17) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  &#125;</span><br><span class="line">  v23 = objc_msgSend(v31, <span class="string">&quot;objectForKeyedSubscript:&quot;</span>, CFSTR(<span class="string">&quot;Email&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)objc_msgSend(v23, <span class="string">&quot;isEqualToString:&quot;</span>, CFSTR(<span class="string">&quot;lizhixiangwang@gmail.com&quot;</span>)) ) <span class="comment">// 黑名单邮箱</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_14:</span><br><span class="line">    v11 = +[DHAnalytics sharedAnalytics](&amp;OBJC_CLASS___DHAnalytics, <span class="string">&quot;sharedAnalytics&quot;</span>);</span><br><span class="line">    objc_msgSend(v11, <span class="string">&quot;trackAppLaunch:&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">    -[DHInApp setThirdB:](self, <span class="string">&quot;setThirdB:&quot;</span>, CFSTR(<span class="string">&quot;fail&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">  &#125;</span><br><span class="line">  v24 = objc_msgSend(v31, <span class="string">&quot;objectForKeyedSubscript:&quot;</span>, CFSTR(<span class="string">&quot;Version&quot;</span>));</span><br><span class="line">  v25 = objc_msgSend(v24, <span class="string">&quot;integerValue&quot;</span>);</span><br><span class="line">  -[DHInApp setLicenseDashVersion:](self, <span class="string">&quot;setLicenseDashVersion:&quot;</span>, v25);</span><br><span class="line">  v26 = -[DHInApp licenseDashVersion](self, <span class="string">&quot;licenseDashVersion&quot;</span>);</span><br><span class="line">  v27 = <span class="number">2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v26 &gt;= <span class="number">3</span> ) <span class="comment">// 过滤错误的版本号</span></span><br><span class="line">    v27 = -[DHInApp licenseDashVersion](self, <span class="string">&quot;licenseDashVersion&quot;</span>, <span class="number">2LL</span>);</span><br><span class="line">  -[DHInApp setLicenseDashVersion:](self, <span class="string">&quot;setLicenseDashVersion:&quot;</span>, v27);</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)-[DHInApp licenseDashVersion](self, <span class="string">&quot;licenseDashVersion&quot;</span>) &lt; <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    -[DHInApp setUpgradeAvailable:](self, <span class="string">&quot;setUpgradeAvailable:&quot;</span>, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)objc_msgSend(&amp;OBJC_CLASS___NSThread, <span class="string">&quot;isMainThread&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      -[DHInApp swapUpgradeView](self, <span class="string">&quot;swapUpgradeView&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">      dispatch_sync(&amp;_dispatch_main_q, v30);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">  &#125;</span><br><span class="line">  -[DHInApp setActivatedByLicense:](self, <span class="string">&quot;setActivatedByLicense:&quot;</span>, <span class="number">1LL</span>);</span><br><span class="line">  -[DHInApp setLoadingString:](self, <span class="string">&quot;setLoadingString:&quot;</span>, CFSTR(<span class="string">&quot;com.barebones.textwrangler&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)objc_msgSend(&amp;OBJC_CLASS___NSThread, <span class="string">&quot;isMainThread&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    -[DHInApp setLicensePurchaseDescription](self, <span class="string">&quot;setLicensePurchaseDescription&quot;</span>);</span><br><span class="line">    -[DHInApp swapGiftView](self, <span class="string">&quot;swapGiftView&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    dispatch_sync(&amp;_dispatch_main_q, block);</span><br><span class="line">  &#125;</span><br><span class="line">  v28 = +[DHAnalytics sharedAnalytics](&amp;OBJC_CLASS___DHAnalytics, <span class="string">&quot;sharedAnalytics&quot;</span>);</span><br><span class="line">  objc_msgSend(v28, <span class="string">&quot;trackAppLaunch:&quot;</span>, <span class="number">1LL</span>);</span><br><span class="line">  <span class="keyword">return</span> -[DHInApp loadingString](self, <span class="string">&quot;loadingString&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在细说上面的结论前，先观察函数的控制流图。</p>
<img src="/2021/08/24/Dash_crack/5.png" class="" alt="Graph">

<p>这是一张有意思的图，通常这种密集的线条极有可能是一个公共的错误处理过程，这里暂称为公共出口。</p>
<p>结合上面的代码，该函数 <code>return</code> 出口共有4个。</p>
<p>其中第一个是激活后一定被触发的，第二是是在激活前必然触发的(可以通过对初始值分析得到)。剩下正确的出口和错误的出口各一个。</p>
<p><code>LABEL_14</code> 属于图中的公共出口，再结合反编译的上下文看，公共出口即为错误处理。也就是说，流程上不进入 <code>goto LABEL_14</code> 即可完成激活。</p>
<p><code>checkurl_and_anti_crack</code> 是完成流程的关键函数。</p>
<img src="/2021/08/24/Dash_crack/6.png" class="" alt="checkurl_and_anti_crack">

<p>又一次见到了 <code>verifier_and_loadDataFromXML</code>，后面会对它一探究竟。</p>
<p>接着看一下另外一个感兴趣的点  <code>base64_pubkey</code>，通过对 <code>create_global_pubkey</code> 函数的内容分析，基本确定该全局变量存放着公钥，内容是通过对字符串 <code>0xAD97B0E07F8C747E2D2......</code>转换得到。</p>
<h2 id="再见-verifier-and-loadDataFromXML"><a href="#再见-verifier-and-loadDataFromXML" class="headerlink" title="再见 verifier_and_loadDataFromXML"></a>再见 <code>verifier_and_loadDataFromXML</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFDictionaryRef __fastcall <span class="title function_">verifier_and_loadDataFromXML</span><span class="params">(<span class="type">const</span> __CFURL *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, a1, &amp;resourceData, <span class="number">0LL</span>, <span class="number">0LL</span>, errorCode) == <span class="number">1</span></span><br><span class="line">    &amp;&amp; !errorCode[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = VerifySignatureFromResourceData(resourceData);</span><br><span class="line">    CFRelease(resourceData);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终需要通过 <code>VerifySignatureFromResourceData</code> 返回字典给外部使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFDictionaryRef __fastcall <span class="title function_">VerifySignatureFromResourceData</span><span class="params">(<span class="type">const</span> __CFData *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="keyword">if</span> ( global_publickey ) <span class="comment">// 判断公钥解密是否正常</span></span><br><span class="line">  &#123;</span><br><span class="line">    errorString = <span class="number">0LL</span>;</span><br><span class="line">    v1 = kCFAllocatorDefault;</span><br><span class="line">    v2 = CFPropertyListCreateFromXMLData(kCFAllocatorDefault, a1, <span class="number">1uLL</span>, &amp;errorString);</span><br><span class="line">    v32[<span class="number">3</span>] = (__int64)v2;</span><br><span class="line">    <span class="keyword">if</span> ( !errorString</span><br><span class="line">      &amp;&amp; (TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID((CFTypeRef)v32[<span class="number">3</span>]))</span><br><span class="line">      &amp;&amp; CFPropertyListIsValid((CFPropertyListRef)v32[<span class="number">3</span>], kCFPropertyListXMLFormat_v1_0) )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = (<span class="type">const</span> __CFDictionary *)v32[<span class="number">3</span>];</span><br><span class="line">      Value = (<span class="type">const</span> __CFData *)CFDictionaryGetValue(v4, CFSTR(<span class="string">&quot;Signature&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> ( Value ) <span class="comment">// 判断证书是否存在 Signature 字段</span></span><br><span class="line">      &#123;</span><br><span class="line">        signature = Value;</span><br><span class="line">        sha_sourceData = (<span class="type">const</span> __CFData *)use_sha_construct_sourceData(v4); <span class="comment">// 构造原始数据</span></span><br><span class="line">        v23[<span class="number">3</span>] = (__int64)sha_sourceData;</span><br><span class="line">        <span class="keyword">if</span> ( sha_sourceData )</span><br><span class="line">        &#123;</span><br><span class="line">          Length = CFDataGetLength(sha_sourceData);</span><br><span class="line">          BytePtr = CFDataGetBytePtr(sha_sourceData);</span><br><span class="line">          Mutable = CFStringCreateMutable(kCFAllocatorDefault, <span class="number">2</span> * Length);</span><br><span class="line">          <span class="keyword">if</span> ( Length &gt; <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v49 = v4;</span><br><span class="line">            v48 = kCFAllocatorDefault;</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != Length; ++i )</span><br><span class="line">              CFStringAppendFormat(Mutable, <span class="number">0LL</span>, CFSTR(<span class="string">&quot;%02X&quot;</span>), BytePtr[i]);</span><br><span class="line">            v1 = v48;</span><br><span class="line">            v4 = v49;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          Mutable = CFStringCreateMutable(kCFAllocatorDefault, <span class="number">0LL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( qword_1003B0B68 )</span><br><span class="line">          CFRelease(qword_1003B0B68);</span><br><span class="line">        qword_1003B0B68 = CFStringCreateCopy(v1, Mutable);</span><br><span class="line">        CFRelease(Mutable);</span><br><span class="line">        v14 = (<span class="type">const</span> __CFArray *)theArray;</span><br><span class="line">        <span class="keyword">if</span> ( !theArray</span><br><span class="line">          || (Count = CFArrayGetCount((CFArrayRef)theArray),</span><br><span class="line">              !CFArrayContainsValue(v14, (CFRange)__PAIR128__(Count, <span class="number">0LL</span>), Mutable)) )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = SecVerifyTransformCreate(global_publickey, signature, (CFErrorRef *)v36 + <span class="number">3</span>);</span><br><span class="line">          v28[<span class="number">3</span>] = (__int64)v16;</span><br><span class="line">          <span class="keyword">if</span> ( !v36[<span class="number">3</span>] )</span><br><span class="line">          &#123;</span><br><span class="line">            SecTransformSetAttribute(v16, kSecTransformInputAttributeName, (CFTypeRef)v23[<span class="number">3</span>], (CFErrorRef *)v36 + <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v36[<span class="number">3</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">              SecTransformSetAttribute(</span><br><span class="line">                (SecTransformRef)v28[<span class="number">3</span>],</span><br><span class="line">                kSecInputIsAttributeName,</span><br><span class="line">                kSecInputIsRaw,</span><br><span class="line">                (CFErrorRef *)v36 + <span class="number">3</span>);</span><br><span class="line">              <span class="keyword">if</span> ( !v36[<span class="number">3</span>] )</span><br><span class="line">              &#123;</span><br><span class="line">                v17 = (<span class="type">const</span> __CFBoolean *)SecTransformExecute((SecTransformRef)v28[<span class="number">3</span>], (CFErrorRef *)v36 + <span class="number">3</span>);  <span class="comment">// 验证原始数据签名</span></span><br><span class="line">                v19[<span class="number">3</span>] = (__int64)v17;</span><br><span class="line">                <span class="keyword">if</span> ( !v36[<span class="number">3</span>] &amp;&amp; kCFBooleanTrue == v17 )</span><br><span class="line">                &#123;</span><br><span class="line">                  Copy = CFDictionaryCreateCopy(v1, v4);</span><br><span class="line">                  v40(v39);</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        CFShow(CFSTR(<span class="string">&quot;No signature&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      v40(v39);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v11 = (<span class="type">const</span> <span class="type">void</span> *)v32[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v11 )</span><br><span class="line">        CFRelease(v11);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CFShow(CFSTR(<span class="string">&quot;Public key is invalid&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  Copy = <span class="number">0LL</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">return</span> Copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里本质是一个签名验证过程，通过证书中的 <code>Signature</code> 及公钥验证证书本身的合法性。</p>
<h2 id="RSA-签名验证"><a href="#RSA-签名验证" class="headerlink" title="RSA 签名验证"></a>RSA 签名验证</h2><p>简单比划一下 <code>RSA签名验证</code> 过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; ： 生成</span><br><span class="line">&lt;-&gt;:  验证</span><br><span class="line"></span><br><span class="line">私钥 -&gt; 公钥</span><br><span class="line">私钥 + 原始数据 -&gt; 签名</span><br><span class="line"></span><br><span class="line">公钥 &lt;-&gt; 原始数据 + 签名</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>use_sha_construct_sourceData</code> 就值得注意了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFTypeRef __fastcall <span class="title function_">use_sha_construct_sourceData</span><span class="params">(CFDictionaryRef theDict)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// .......</span></span><br><span class="line">  Count = CFDictionaryGetCount(theDict);</span><br><span class="line">  allocator = kCFAllocatorDefault;</span><br><span class="line">  theArray = CFArrayCreateMutable(kCFAllocatorDefault, Count, <span class="number">0LL</span>);</span><br><span class="line">  v36 = &amp;v22;</span><br><span class="line">  v2 = (<span class="type">const</span> <span class="type">void</span> **)((<span class="type">char</span> *)&amp;v22 - ((<span class="number">8</span> * Count + <span class="number">15</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF0L</span>L));</span><br><span class="line">  CFDictionaryGetKeysAndValues(theDict, v2, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Count &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != Count; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( CFStringCompare((CFStringRef)v2[i], CFSTR(<span class="string">&quot;Signature&quot;</span>), <span class="number">0LL</span>) )<span class="comment">// 排除 Signature</span></span><br><span class="line">        CFArrayAppendValue(theArray, v2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = theArray;</span><br><span class="line">  CFArraySortValues(theArray, (CFRange)__PAIR128__(Count - <span class="number">1</span>, <span class="number">0LL</span>), (CFComparatorFunction)&amp;_CFStringCompare, (<span class="type">void</span> *)<span class="number">1</span>);<span class="comment">// 字典转成数组并根据字符大小排序</span></span><br><span class="line">  v6 = allocator;</span><br><span class="line">  theData = CFDataCreateMutable(allocator, <span class="number">0LL</span>);</span><br><span class="line">  v7 = CFArrayGetCount(v5);</span><br><span class="line">  <span class="keyword">if</span> ( v7 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j != v8; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      ValueAtIndex = CFArrayGetValueAtIndex(v5, j);</span><br><span class="line">      Value = (<span class="type">const</span> __CFString *)CFDictionaryGetValue(theDict, ValueAtIndex);</span><br><span class="line">      ExternalRepresentation = CFStringCreateExternalRepresentation(v6, Value, <span class="number">0x8000100u</span>, <span class="number">0</span>);</span><br><span class="line">      BytePtr = CFDataGetBytePtr(ExternalRepresentation);</span><br><span class="line">      Length = CFDataGetLength(ExternalRepresentation);</span><br><span class="line">      v15 = BytePtr;</span><br><span class="line">      v5 = theArray;</span><br><span class="line">      CFDataAppendBytes(theData, v15, Length);</span><br><span class="line">      v16 = ExternalRepresentation;</span><br><span class="line">      v6 = allocator;</span><br><span class="line">      CFRelease(v16);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v17 = theData;</span><br><span class="line">  v18 = SecDigestTransformCreate(kSecDigestSHA1, <span class="number">0LL</span>, (CFErrorRef *)v33 + <span class="number">3</span>);</span><br><span class="line">  v23[<span class="number">3</span>] = (__int64)v18;</span><br><span class="line">  <span class="keyword">if</span> ( v33[<span class="number">3</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    CFRelease(v17);</span><br><span class="line">    v28();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SecTransformSetAttribute(v18, kSecTransformInputAttributeName, v17, (CFErrorRef *)v33 + <span class="number">3</span>); <span class="comment">// 对数据进行 sha 取样</span></span><br><span class="line">    v19 = SecTransformExecute((SecTransformRef)v23[<span class="number">3</span>], (CFErrorRef *)v33 + <span class="number">3</span>);</span><br><span class="line">    CFRelease(v17);</span><br><span class="line">    v21 = v33[<span class="number">3</span>];</span><br><span class="line">    v28();</span><br><span class="line">    <span class="keyword">if</span> ( !v21 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12; <span class="comment">// 返回待验证的数据</span></span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">      CFRelease(v19);</span><br><span class="line">  &#125;</span><br><span class="line">  v19 = <span class="number">0LL</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">return</span> v19;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此可以得到一个较为完整的算法过程</p>
<ol start="0">
<li>使用某字节转换算法将 <code>base64_pubkey</code> 转换，然后使用 <code>kSecBase64Encoding</code> 编码拼接得到公钥</li>
<li>把排除 <code>Signature</code> 的字段的值合并为数组，在 <code>Sort</code> 排序及其他处理后使用 <code>SHA1</code> 取样作为待验证数据</li>
<li>通过 <code>待验证数据</code>  <code>pubkey</code>  <code>Signature</code> 完成校验</li>
</ol>
<h2 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h2><ol>
<li>公钥替换并实现注册机，需要反推 <code>base64_pubkey</code></li>
<li>字节补丁，对部分流程绕过处理</li>
</ol>
<p>虽然公钥替换可以相对避免暗桩等问题，但步骤较为麻烦。本文采用字节补丁的方式完成验证。</p>
<p>需要打补丁的有两处:</p>
<ol>
<li>使 <code>VerifySignatureFromResourceData</code> 中的签名验证部分恒返回真</li>
<li>绕开 <code>DHInApp displayString</code> 的无效文件验证</li>
</ol>
<p>同时根据需求字段构造文件构造一个假的 <code>license.dash-license</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple Computer//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>piz-ewing@gmail.com<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>6<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Signature<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span>piz-ewing</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>切换至 <code>arm</code> 版本，定位到关键点，打上补丁。</p>
<img src="/2021/08/24/Dash_crack/7.png" class="" alt="Activated">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000010004f7c8 CMP X8, X0                    -&gt;  CMP X8, X8</span><br><span class="line">00000001000AFE44 CBNZ W0, loc_1000AFE54        -&gt;  NOP</span><br></pre></td></tr></table></figure>



<p>尝试激活，简单修改系统时间验证。</p>
<img src="/2021/08/24/Dash_crack/8.png" class="" alt="Activated">

<p>至此基本完成了Dash的破解思路验证。可能会有其他暗桩需要在实际使用中遇到后分析处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是窥探一下 <code>OSX</code>软件的常用验证方法及破解思路，欢迎讨论与共同学习。</p>
<p><code>Dash</code> 是一款很不错的软件，建议有能力的朋友可以支持正版软件发展。</p>
]]></content>
      <tags>
        <tag>OSX M1(Apple Sillcon) 逆向工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Engintime系列逆向分析(1)--协议分析</title>
    <url>/2019/12/30/Engintime_protocol_analysis/</url>
    <content><![CDATA[<h2 id="坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。"><a href="#坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。" class="headerlink" title="坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。"></a><strong>坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。</strong></h2><span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日发现Engintime的那套软件更新了，转移到了 <a href="http://www.codecode.net/" title="codecode">CodeCode</a>，以前老版本记得分析过，就是个真<code>demo</code>，这回新版本看它的描述并不是<code>demo</code>，遂打算分析一番。</p>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>我选择从 <code>Engintime OS Lab</code> 开始分析，实际上他一系列的几款区别并不大并且都没有加壳。<br>首先，祭出分析工具。<br>由于此软件是 32位软件，本文使用了动态分析工具 <code>Ollydbg</code>。</p>
<h2 id="寻找突破口"><a href="#寻找突破口" class="headerlink" title="寻找突破口"></a>寻找突破口</h2><p>运行软件，寻找突破口，看到形如 <code>登录失败：用户名或密码错误</code>。<br>这就是一个天然存在的突破口，只要目标软件没有使用一些奇怪的异步框架就能很快定位到关键点</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010173953090.png" class="" alt="image-20221010173953090">



<p><strong><code>OD</code> 附加之，通过查找<code>UNICODE</code>字符串，定位之。</strong></p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174009796.png" class="" alt="image-20221010174009796">



<p>从上图中，可以得知以下内容</p>
<blockquote>
<ol>
<li>软件使用了 cpprestsdk 库</li>
<li>此处是 请求返回的结果处理</li>
<li>结果包应该是一个 状态码为 200 并且 body 部分是一个json<br>其格式为 {“access_token”:””}</li>
</ol>
</blockquote>
<p>为什么不尝试爆破?<br>一般来说，带网络验证的程序，其程序内部可能存在一些全局数据需要初始化 例如 版本号，标题，加解密key等，<br>如果简单的爆破可能导致这些数据不能被初始化而导致未知错误。</p>
<p><strong>在本软件中，协议相对简单，从协议出发更为合理。</strong></p>
<h2 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h2><p>此时祭出协议调试套装 <code>Proxifier</code> + <code>Fiddler 4</code>。</p>
<p>为何要使用 <code>Proxifier</code>?<br>在 <code>cpprestsdk</code> 库中，可以选择代理模式和非代理模式，若只用 <code>Fiddler 4</code> 作为系统代理，在本软件中是抓不到数据包的。</p>
<p>简单配置 <code>Proxifier</code> <code>Fiddler 4</code></p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174037871.png" class="" alt="image-20221010174037871">

<p>再次登录，会获得如下数据</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174053100.png" class="" alt="image-20221010174053100">

<p>根据之前的分析，需要重新构造一个数据包返回，其构造如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;access_token&quot;: &quot;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>Fiddler 4</code> 的 <code>AutoResponder</code> 功能对包进行替换</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174117713.png" class="" alt="image-20221010174117713">

<p><code>token.txt</code> 中就是上面的返回内容，再次点击登录</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174128042.png" class="" alt="image-20221010174128042">

<p>同时在 <code>Fiddler 4</code> 中能的到一请求地址为 <code>https://www.codecode.net/api/v4/clientauthorizedcode</code></p>
<p>继续使用 OD 查找 <code>登录失败：获取授权失败</code></p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174143915.png" class="" alt="image-20221010174143915">

<p>这里就不贴全了，其逻辑和之前第一个包的逻辑类似。<br>中间有个稍微特别一点的。</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174201791.png" class="" alt="image-20221010174201791">


<p>得到json格式之后，先不管其内容具体意义，构造 <code>Response</code> 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;message&quot;:&quot;0&quot;,</span><br><span class="line">&quot;number&quot; : 0,</span><br><span class="line">&quot;ban_count&quot;:0,</span><br><span class="line">&quot;email&quot;:&quot;&quot;,</span><br><span class="line">&quot;name&quot;:&quot;&quot;,</span><br><span class="line">&quot;username&quot;:&quot;&quot;,</span><br><span class="line">&quot;inforId&quot;:&quot;&quot;,</span><br><span class="line">&quot;inforContent&quot;:&quot;&quot;,</span><br><span class="line">&quot;threedeskey&quot;:[0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5],</span><br><span class="line">&quot;auth_state&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故技重施，在登录成功之后，出现了加载页面，然后程序就退出了。</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174231563.png" class="" alt="image-20221010174231563">

<p>到此为止了么？<br>真是山穷水尽。</p>
<h2 id="山穷水尽"><a href="#山穷水尽" class="headerlink" title="山穷水尽"></a>山穷水尽</h2><p>此时崩溃的原因可能有很多，</p>
<ol>
<li>json 内容错误</li>
<li>是软件自身bug</li>
<li>…</li>
</ol>
<p>如果是json内容错误还好说，要是软件本身有bug，可就难受了。</p>
<p>那就先假设是软件bug，他有一系列软件，不可能全都有bug，换一个试一下。</p>
<h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>重新在 <code>Engintime CP Lab</code> 中验证，运行之，</p>
<img src="/2019/12/30/Engintime_protocol_analysis/image-20221010174305637.png" class="" alt="image-20221010174305637">

<p>成功打开了。<br>剩下的几个都测了一下，有的能打开有的打不开。</p>
<p>不可能这些全部都存在bug，<br>那么就需要回到<code>json</code>内容错误继续分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过字符打开突破口，通过<code>Response</code>替换，成功运行该系列的部分软件。</p>
<p>下一篇中，我将继续分析 <code>json</code>内容错误。</p>
]]></content>
      <tags>
        <tag>crack protocol_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Engintime系列逆向分析(2)--SMC与3DES</title>
    <url>/2019/12/31/Engintime_protocol_analysis_2/</url>
    <content><![CDATA[<h2 id="坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。"><a href="#坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。" class="headerlink" title="坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。"></a><strong>坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。</strong></h2><span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇中，分析到了 <code>json</code> 内容错误这里，<br>接下来就需要具体去探索为何会错误了。</p>
<h2 id="错在哪里"><a href="#错在哪里" class="headerlink" title="错在哪里"></a>错在哪里</h2><p>回到 <code>Engintime OS Lab</code> ，在结束进程相关函数(<code>ExitProcess</code> <code>TerminateProcess</code> 等)上面下断点，<br>可以看出并不是程序主动退出，那么可能的原因是异常无法处理而退出的，通过对退出时的栈信息进行判断可以证明这一点。</p>
<p>可惜的是，我用的这个版本的 <code>od</code> 无论怎么关闭忽略异常都不会接管，所以暂时换了<code>vs</code>的调试器。</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010174819713.png" class="" alt="image-20221010174819713">

<p>另外，此程序并未启用随机基址，故这个地址是不变的。</p>
<blockquote>
<p>0x00633E32</p>
</blockquote>
<h2 id="分析异常成因"><a href="#分析异常成因" class="headerlink" title="分析异常成因"></a>分析异常成因</h2><p>IDA 查看之</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010174851144.png" class="" alt="image-20221010174851144">

<p>可以得到以下信息</p>
<blockquote>
<ol>
<li>异常位于数据段</li>
<li>在异常代码片段之前是正常代码片段</li>
<li>从 CODE XREF(交叉引用来看) 是从 sub_634B40+435↓p 处正常调用到此处</li>
</ol>
</blockquote>
<p>od动态看一下</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010174907369.png" class="" alt="image-20221010174907369">

<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010174918846.png" class="" alt="image-20221010174918846">

<p>在函数  <code>sub_460320</code> 调用前后，异常内容发生了变换，<br>初步猜测，函数  <code>sub_460320</code> 会改变即将执行的内容即解密。</p>
<p>为了看的清晰一些，使用了 <code>IDA</code> 的 <code>Hex-Rays Decompiler</code> 插件，俗称 <code>F5</code>插件。</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010174939715.png" class="" alt="image-20221010174939715">


<p>得到如下结论</p>
<blockquote>
<ol>
<li>retaddr 即返回地址是参数的一部分</li>
<li>retaddr 的前4个字节不为 0x48404840 时，进行解密</li>
<li>解密完成后 前8个字节为 0x48404840 0x48404840</li>
</ol>
</blockquote>
<p>这是典型的 <code>SMC加密</code> 方式。</p>
<p>##SMC加密</p>
<blockquote>
<p>SMC是一种局部代码加密技术，通过对一段代码进行加密来达到增加逆向工程难度或者免杀的目的。</p>
</blockquote>
<p>具体的内容，网上一搜到处都是。<br><strong>参考</strong></p>
<ul>
<li><a href="https://blog.csdn.net/PandaOS/article/details/46575441">VC实现SMC加密技术_PandaOS的博客-CSDN博客</a></li>
</ul>
<p>这种加密有个特点，就是静态<code>key</code>，一旦<code>key</code>被<code>dump</code>出来了，这个软件就能被共享出去。</p>
<p>通常情况下，这个<code>key</code>，必须要授权才能得到，也有例外情况。</p>
<p>接下来重点就是看 <code>sub_5E6550</code> 的行为</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010175027323.png" class="" alt="image-20221010175027323">

<p>通过动态观察其参数，又能得到如下信息</p>
<blockquote>
<p>retaddr 的4-8字节中存放有待解密长度，解密块从长度之后开始计数<br>最后一个参数中存放着先前<code>clientauthorizedcode</code>返回的<code>json</code>中的 [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5]。</p>
</blockquote>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010175039491.png" class="" alt="image-20221010175039491">

<p>通过对比置换表等特征，可以确定是 <code>3des</code> 加密，<br>我并未具体分析<code>sub_5E6550</code>如何实现，<br>只是根据行为进行推断，这点会影响后面破解器的编写。</p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><blockquote>
<p>3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。</p>
</blockquote>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/ebcce1beafaf" title="对称加密算法：DES、3DES">对称加密算法：DES、3DES</a></li>
<li><a href="https://github.com/yudansan/3des">github: 3des</a></li>
</ul>
<p>由于是用3des 做的 SMC加密，老实说比较没辙，就算知道<br><code>明文</code>  <code>密钥长度</code> <code>密文</code><br>还是无法求得密钥，那么就避免不了需要穷举了(<strong>最少我不知道如何求解</strong>)。</p>
<p>通过对能成功运行的 <code>CP Lab</code> 对比分析，还原了异常代码片段</p>
<img src="/2019/12/31/Engintime_protocol_analysis_2/image-20221010175151284.png" class="" alt="image-20221010175151284">

<p><strong>由于程序多处进行了加密，故还原一处并无大用，但是可以写出一个破解器。</strong></p>
<h2 id="暴力破解器"><a href="#暴力破解器" class="headerlink" title="暴力破解器"></a>暴力破解器</h2><p>这个暴力破解器有两种写法</p>
<ol>
<li>提取出加密数据，外部自行使用 <code>3des</code>库，同时需要还原解密逻辑</li>
<li>直接注入程序，调用程序原有的解密程序</li>
</ol>
<p>由于我不想在这个东西上浪费时间，通常来说，暴力破解是非常耗时间的，这里我只给出第二种写法的验证算法，这种写法的好处在于，我不用管它内部是怎么样加密变换的，只需要知道</p>
<blockquote>
<p>加密块 + 加密密钥 + 解密入口 &#x3D; 解密块</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经过修改的验证算法，调用原程序的解密算法，并修改 retaddr 为指定的加密块起始地址</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">sub_460320</span><span class="params">(<span class="type">char</span>* key, <span class="type">char</span>* start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">    <span class="type">char</span>* v2; <span class="comment">// esi</span></span><br><span class="line">    <span class="type">int</span> v3; <span class="comment">// [esp+10h] [ebp-2Ch]</span></span><br><span class="line">    <span class="type">char</span>* v4; <span class="comment">// [esp+28h] [ebp-14h]</span></span><br><span class="line">    DWORD* v5; <span class="comment">// [esp+2Ch] [ebp-10h]</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// [esp+38h] [ebp-4h]</span></span><br><span class="line">    <span class="type">void</span>* retaddr = start; <span class="comment">// [esp+40h] [ebp+4h]</span></span><br><span class="line">    <span class="type">int</span> retv = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    v4 = (<span class="type">char</span>*)key;</span><br><span class="line">    v5 = (DWORD*)retaddr;</span><br><span class="line">    v1 = *(DWORD*)retaddr;</span><br><span class="line">    <span class="keyword">if</span> (*(DWORD*)retaddr != <span class="number">0x48404840</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v2 = (<span class="type">char</span>*)*((DWORD*)retaddr + <span class="number">1</span>); <span class="comment">// 168</span></span><br><span class="line">        __asm &#123;</span><br><span class="line">            lea ecx, v3</span><br><span class="line">            mov eax, <span class="number">0x005E5CF0</span></span><br><span class="line">            call eax</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cret = (<span class="type">int</span>)retaddr + <span class="number">8</span>; <span class="comment">// 31</span></span><br><span class="line">        __asm &#123;</span><br><span class="line">            lea ecx, v3</span><br><span class="line">            push v4</span><br><span class="line">            push v2</span><br><span class="line">            push cret</span><br><span class="line">            push v2</span><br><span class="line">            push cret</span><br><span class="line">            mov eax, <span class="number">0x005E6550</span></span><br><span class="line">            call eax</span><br><span class="line">            mov retv, eax</span><br><span class="line">        &#125;</span><br><span class="line">        *v5 = <span class="number">0x48404840</span>;</span><br><span class="line">        v5[<span class="number">1</span>] = <span class="number">0x48404840</span>;</span><br><span class="line">        v5 = (DWORD*)((<span class="type">char</span>*)retaddr + v1 + <span class="number">8</span>);</span><br><span class="line">        *v5 = <span class="number">0x48404840</span>;</span><br><span class="line">        v5[<span class="number">1</span>] = <span class="number">0x48404840</span>;</span><br><span class="line">        __asm &#123;</span><br><span class="line">            lea ecx, v3</span><br><span class="line">            mov eax, <span class="number">0x005E5D00</span></span><br><span class="line">            call eax</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYSIZE (0x178)</span></span><br><span class="line"><span class="type">char</span> memencode[COPYSIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">verify</span><span class="params">(<span class="type">char</span>* key, <span class="type">int</span> keylen)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(memencode, (<span class="type">char</span>*)<span class="number">0x00633E29</span>, COPYSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sub_460320</span>(key, memencode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解密结果</span></span><br><span class="line">    <span class="comment">// Write2Con(&quot;[+] ---- Key ----\r\n&quot;);</span></span><br><span class="line">    <span class="comment">// Write2Con(PrintBuffer(key, keylen));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write2Con(&quot;[+] ---- decode ----\r\n&quot;);</span></span><br><span class="line">    <span class="comment">// Write2Con(PrintBuffer(memencode, 0x50));</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，以上代码并不是真正的破解器，只是简单验证算法，<br>其效率低下，如果感兴趣，可以根据逻辑自行优化。</p>
<h2 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h2><p>方案一:<br>通过其他渠道获取到正确的 <code>3dskey</code></p>
<p>方案二:<br>将已知可用(已解密)的<code>exe以dll方式加载</code>到目标进程内存，<br><code>hook解密函数</code>，根据<code>特征码</code>，匹配到指定已解密函数，并跳转到已解密函数继续执行，<br>需要在解密函数到达时<code>动态提取</code>特征码并匹配。<br>难点在于特征的动态提取。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过逐层分析，已经对该系列软件的验证方式得到了一个较为具体的理解。</p>
<p>现在知道了，该系列的部分不需要正确的 <code>3dskey</code> 能正常工作，部分则需要，以及这个<code>key</code>的作用。<br>下一篇中，将写出一个较为通用的工具，也算是对整个逆向过程的总结。</p>
]]></content>
      <tags>
        <tag>crack protocol_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Engintime系列逆向分析(3)--工具开发</title>
    <url>/2019/12/31/Engintime_protocol_analysis_3/</url>
    <content><![CDATA[<h2 id="坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。"><a href="#坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。" class="headerlink" title="坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。"></a><strong>坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。</strong></h2><span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经对这个软件的验证进行了比较清晰的分析，<br>接下来就该写出一个完整工具了。</p>
<h2 id="思路呢"><a href="#思路呢" class="headerlink" title="思路呢?"></a>思路呢?</h2><p>首先总不能把<code>fiddler</code>作为工具的一部分吧。</p>
<p>那么需要模拟收发包才行，<br>在开始分析时就提过了原程序使用的<code>cpprestsdk</code>，故 <code>cpprestsdk</code>将成为突破口。</p>
<p>方案一:<br><code>cpprestsdk</code>内部使用的是 <code>WinHttpxxx</code> 函数收发包，<br>由于 <code>cpprestsdk</code> 利用的是异步收发，<br>在尝试了 <code>HOOK</code> <code>WinHttpxxx</code> 系列函数直接返回后，<br>总会出现莫名其妙的崩溃，<br>就算尝试交付其完成函数也是一个结果。<br>为了测试这种方案，耗费了数个小时，有兴趣的可以试试。<br>里面涉及多线程及锁重入问题，就不再细说了。</p>
<p>方案二:<br>既然从底层劫持收发包不行，那能不能从库本身入手呢？<br>答案是可以的。</p>
<p>下面是 <code>cpprestsdk</code> 在编写客户端时常用的写法，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">http_client <span class="title">client</span><span class="params">(U(<span class="string">&quot;http://www.bing.com/&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">// Build request URI and start the request.</span></span><br><span class="line"><span class="function">uri_builder <span class="title">builder</span><span class="params">(U(<span class="string">&quot;/search&quot;</span>))</span></span>;</span><br><span class="line">builder.<span class="built_in">append_query</span>(<span class="built_in">U</span>(<span class="string">&quot;q&quot;</span>), <span class="built_in">U</span>(<span class="string">&quot;cpprestsdk github&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> client.<span class="built_in">request</span>(methods::GET, builder.<span class="built_in">to_string</span>());</span><br></pre></td></tr></table></figure>

<p>如果我们能替换掉 “<a href="http://www.bing.com/">http://www.bing.com/</a>“ 为指向本地的通信，不就能替换掉 <code>Response</code> 包了么?</p>
<p>![[Engintime_protocol_analysis_3&#x2F;image-20221010175446393.png]]</p>
<p>从<code>cpprestsdk</code>的导出函数下断可以轻松定位到相关代码。</p>
<p>首先尝试修改了 <code>uri</code> 给定的参数,<br>但发现程序会出现失败提示，<br>原因是，在调用<code>uri</code>时，传入的字符串只是一个副本，<br>修改副本并不能改变本体，在其他地方可能不会使用这个副本，所以通信会失败。<br>通过继续分析，发现真正的本体会经过 <code>mf140u.#1663</code>,就是上图画红线那个函数调用。</p>
<p>于是继续尝试编写代码 <code>HOOK</code> 之并替换。<br>需要注意的是，替换的串最好不要长于原始串，<br>由于没有分析原始串内存是位于哪里，溢出可能会崩溃。</p>
<h2 id="注入进程"><a href="#注入进程" class="headerlink" title="注入进程"></a>注入进程</h2><p>这里使用常见的映像劫持，劫持掉 <code>winhttp.dll</code><br>关于劫持怎么写，<br>在 [巧用DLL劫持做黑盒分析] 一文中已详细描述。</p>
<p>简单改下入口就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DisableThreadLibraryCalls</span>(hModule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Load</span>() &amp;&amp; <span class="built_in">Init</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 功能入口</span></span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, Do, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwReason == DLL_PROCESS_DETACH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Free</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HOOK与转向"><a href="#HOOK与转向" class="headerlink" title="HOOK与转向"></a>HOOK与转向</h2><p>这段代码使用了 <code>Detour</code> 框架来 <code>hook</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> PVOID cpprest_uri = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">wchar_t</span>* newUri = <span class="string">L&quot;http://127.0.0.1:13303/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">wchar_t</span>** sstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> bfix = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FixUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">wcscmp</span>(*sstr, <span class="string">L&quot;https://www.codecode.net/&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(*sstr, newUri, (<span class="built_in">wcslen</span>(newUri) + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">        bfix = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">FixFunc</span>() &#123;</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">         mov sstr,ecx</span><br><span class="line">         pushad</span><br><span class="line">         pushfd</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!bfix) <span class="built_in">FixUrl</span>();</span><br><span class="line"></span><br><span class="line">    __asm &#123;</span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">        jmp cpprest_uri</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dropHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">    <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpprest_uri) <span class="built_in">DetourDetach</span>((PVOID*)&amp;cpprest_uri, FixFunc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DetourTransactionCommit</span>() == NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">setHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> moduleBase = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;mfc140u.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!moduleBase)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    cpprest_uri = <span class="built_in">GetProcAddress</span>(moduleBase, (<span class="type">char</span>*)<span class="number">1663</span>);</span><br><span class="line">    <span class="keyword">if</span> (!cpprest_uri)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// _CIP&lt;IBindStatusCallback, &amp;_GUID const IID_IBindStatusCallback&gt;::operator IBindStatusCallback * (void)mfc140u</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">    <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpprest_uri) <span class="built_in">DetourAttach</span>((PVOID*)&amp;cpprest_uri, FixFunc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DetourTransactionCommit</span>() == NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Do</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setHook</span>();</span><br><span class="line">    <span class="comment">// 后面才用到</span></span><br><span class="line">    <span class="built_in">startServer</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>FixUrl</code> 的用处是防止 <code>release</code> 编译时给优化了，<code>inline</code> 在此并不会起作用，可有可无。<br><code>dropHook</code>并未调用，有兴趣可以自己试试。</p>
<h2 id="http-simple-server"><a href="#http-simple-server" class="headerlink" title="http simple server"></a>http simple server</h2><p>我直接考虑使用第三方框架，而没有在以前写的 <code>server</code> 上改<br>开始时打算使用程序自带的 <code>cpprestsdk</code>，后面感觉还是用更具备通用性的框架比较好。</p>
<p>对于这个第三方的<code>server</code>库有几点要求</p>
<ol>
<li>轻量级,易嵌入的，不需要过于复杂的功能，不需要考虑并发，异步</li>
<li>最好支持 <code>route</code>，便于编写</li>
<li><del>如果能支持<code>https</code>以及代理转发就更好了</del></li>
</ol>
<p>翻来覆去看了几个框架，最终选择了基于<code>mongoose</code>的简易<code>server</code></p>
<ul>
<li><a href="https://blog.csdn.net/u012234115/article/details/79596826" title="C++实现轻量级极简httpserver和httpclient（提供http和websocket接口）">C++实现轻量级极简httpserver和httpclient（提供http和websocket接口）</a></li>
</ul>
<p>在这份代码的基础上进行简单修改，使其能符合使用需求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startServer.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> szCurName[MAX_PATH];</span><br><span class="line"><span class="type">static</span> std::string jkey;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* head =</span><br><span class="line"><span class="string">&quot;Content-Type: application/json; charset=utf-8\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Connection: close\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Cache-Control : no-store\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Pragma : no-cache\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">handle_token</span><span class="params">(std::string url, std::string body, mg_connection* c, OnRspCallback rsp_callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* token =</span><br><span class="line">        <span class="string">&quot;&#123;\&quot;access_token\&quot;: \&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mg_send_response_line</span>(c,  <span class="number">200</span>, head);</span><br><span class="line">    <span class="built_in">mg_printf</span>(c, <span class="string">&quot;%s&quot;</span>, token);</span><br><span class="line">    c-&gt;flags |= MG_F_SEND_AND_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">handle_key</span><span class="params">(std::string url, std::string body, mg_connection* c, OnRspCallback rsp_callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mg_send_response_line</span>(c, <span class="number">200</span>, head);</span><br><span class="line">    <span class="built_in">mg_printf</span>(c, <span class="string">&quot;%s&quot;</span>, jkey.<span class="built_in">c_str</span>());</span><br><span class="line">    c-&gt;flags |= MG_F_SEND_AND_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GetModuleFileNameA</span>(<span class="literal">NULL</span>, szCurName, MAX_PATH);</span><br><span class="line">    <span class="built_in">PathStripPathA</span>(szCurName);</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">// 利用 RAII 回收相关资源</span></span><br><span class="line">        std::string defkey = <span class="string">&quot;[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> nlohmann::json;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;winhttp_3deskey.json&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (in) <span class="comment">// 有该文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::string <span class="title">sjson</span><span class="params">((std::istreambuf_iterator&lt;<span class="type">char</span>&gt;(in)),</span></span></span><br><span class="line"><span class="params"><span class="function">                               std::istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> js = json::<span class="built_in">parse</span>(sjson)[szCurName];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不依赖库异常，自己拆开判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (!js.<span class="built_in">empty</span>()) defkey = js.<span class="built_in">get</span>&lt;std::string&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (json::exception&amp;) &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jkey =</span><br><span class="line">            std::<span class="built_in">string</span>(<span class="string">&quot;&#123;&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;message\&quot;:\&quot;0\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;number\&quot; : 0,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;ban_count\&quot;:0,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;email\&quot;:\&quot;\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;name\&quot;:\&quot;\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;username\&quot;:\&quot;Welcome\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;inforId\&quot;:\&quot;\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;inforContent\&quot;:\&quot;Welcome!\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot;\&quot;threedeskey\&quot;:&quot;</span>) +</span><br><span class="line">                defkey +</span><br><span class="line">                std::<span class="built_in">string</span>(<span class="string">&quot;,&quot;</span></span><br><span class="line">                    <span class="string">&quot;\&quot;auth_state\&quot;:true&quot;</span></span><br><span class="line">                    <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> http_server = std::<span class="built_in">shared_ptr</span>&lt;HttpServer&gt;(<span class="keyword">new</span> HttpServer);</span><br><span class="line">    http_server-&gt;<span class="built_in">Init</span>(<span class="string">&quot;13303&quot;</span>);</span><br><span class="line">    <span class="comment">// add handler</span></span><br><span class="line">    http_server-&gt;<span class="built_in">AddHandler</span>(<span class="string">&quot;/oauth/token&quot;</span>, handle_token);</span><br><span class="line">    http_server-&gt;<span class="built_in">AddHandler</span>(<span class="string">&quot;/api/v4/clientauthorizedcode&quot;</span>, handle_key);</span><br><span class="line">    http_server-&gt;<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http_server.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer::HandleHttpEvent</span><span class="params">(mg_connection* connection, http_message* http_req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string req_str = std::<span class="built_in">string</span>(http_req-&gt;message.p, http_req-&gt;message.len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先过滤是否已注册的函数回调</span></span><br><span class="line">    std::string url = std::<span class="built_in">string</span>(http_req-&gt;uri.p, http_req-&gt;uri.len);</span><br><span class="line">    std::string body = std::<span class="built_in">string</span>(http_req-&gt;body.p, http_req-&gt;body.len);</span><br><span class="line">    <span class="keyword">auto</span> it = s_handler_map.<span class="built_in">find</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (it != s_handler_map.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ReqHandler handle_func = it-&gt;second;</span><br><span class="line">        <span class="built_in">handle_func</span>(url, body, connection, &amp;HttpServer::SendHttpRsp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他请求 正常应该是转发逻辑，这里就临时这样实现一下</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">route_check</span>(http_req, (<span class="type">char</span>*)<span class="string">&quot;/&quot;</span>)) <span class="comment">// index page</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mg_send_response_line</span>(connection, <span class="number">200</span>, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">mg_printf</span>(connection, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;&lt;script&gt;location.href = &#x27;https://www.codecode.net&#x27;;&lt;/script&gt;&quot;</span>);</span><br><span class="line">        connection-&gt;flags |= MG_F_SEND_AND_CLOSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SendHttpRsp</span>(connection, <span class="string">&quot;welcome to jsonapi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译生成"><a href="#编译生成" class="headerlink" title="编译生成"></a>编译生成</h2><ul>
<li><del>[Engintime.rar]</del></li>
</ul>
<p>配置格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;//&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 进程名 : 3deskey 当不填key时会使用默认的key 0-15,在需要key的几款软件中会崩溃&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CP Lab.exe&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>验证:<br>其中 <code>CP</code>,<code>CS</code>,<code>DS</code>等均能正常工作，但并未彻底测试。</p>
<p><strong>由于使用了 <code>SMC</code> 所有授权的<code>key</code>都是一样的 不存在身份泄露风险</strong><br><strong>当然这个<code>key</code>只有在相应的版本(强制更新版本)下才有意义</strong><br><strong>另外这个<code>key</code>不能轻易更换，否则会导致大量用户需要升级，根据包内容看，并没有强制升级功能</strong><br><strong>如果你愿意分享<code>key</code>来供研究学习测试</strong><br><strong>欢迎在评论区留言 <code>软件 + 版本号 + key</code></strong></p>
<p>当前版本号:</p>
<blockquote>
<p>Engintime ASM Lab Setup_3.0.9.msi<br>Engintime C&amp;C++ Lab Setup_3.0.16.msi<br>Engintime CP Lab Setup_3.0.9.msi<br>Engintime CS Lab Setup_3.0.7.msi<br>Engintime Dream Logic 2019 Setup_3.0.24.msi<br>Engintime DS Lab Setup_3.0.13.msi<br>Engintime Eclipse Setup_windows_x64_3.0.1.msi<br>Engintime Linux Lab Setup_3.0.12.msi<br>Engintime OS Lab Setup_3.0.8.msi</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个系列到这里就算完整的结束了。<br>中间遇到了许多细微的细节问题，由于篇幅就不一一道来。</p>
<p><strong>工程本身就不公开了，中了夹杂了很多测试代码没整理，贸然开源反而混乱。</strong><br><strong>上文中的代码片段包含了所有经过整理的核心代码，更具备参考价值。</strong></p>
<p>总结成一句话，逆向分析靠猜想和验证来驱动，正向开发靠需求驱动。</p>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><p>另外在分析完成之后，还简单分析了一下它是如何实现调试的。<br>利用了 <code>GDB MI</code> 接口。<br>关键词:<br><code>GDB MI</code> <code>CreateProcessW</code> <code>CreatePipe</code> <code>ReadFile</code> <code>WriteFile</code> <code>管道通信</code></p>
<hr>
<h2 id="文章免责声明"><a href="#文章免责声明" class="headerlink" title="文章免责声明"></a>文章免责声明</h2><blockquote>
<p>本系列文章仅供研究学习，切勿用做非法之事。<br>如果喜欢本系列软件并准备长期使用，请购买正版，支持软件开发者继续改进和增强本软件的功能。</p>
</blockquote>
]]></content>
      <tags>
        <tag>crack protocol_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Android app协议分析之如何用模拟器抓https数据包</title>
    <url>/2019/12/16/android_app_protocol_analysis/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日因需分析一款app协议，遂记录。</p>
<hr>
<h2 id="一、基础方案"><a href="#一、基础方案" class="headerlink" title="一、基础方案"></a>一、基础方案</h2><h3 id="1-fiddler-雷电"><a href="#1-fiddler-雷电" class="headerlink" title="1.fiddler + 雷电"></a>1.<code>fiddler</code> + <code>雷电</code></h3><p><strong>去掉作为系统代理后重启fiddler</strong></p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173249731.png" class="" alt="image-20221010173249731">

<p><strong>设置WIFI代理</strong></p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173305692.png" class="" alt="image-20221010173305692">


<p><strong>安装本地根证书</strong></p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173316333.png" class="" alt="image-20221010173316333">


<h3 id="2-提示证书有问题"><a href="#2-提示证书有问题" class="headerlink" title="2.提示证书有问题"></a>2.提示证书有问题</h3><p><code>fiddler</code>中能抓到部分 <code>http/s</code> 包<br><strong>依旧提示证书有问题</strong></p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173333328.png" class="" alt="image-20221010173333328">



<h3 id="3-证书权限不足"><a href="#3-证书权限不足" class="headerlink" title="3.证书权限不足"></a>3.证书权限不足</h3><p>可能是证书权限不足<br>也可能是其他问题</p>
<p>期间尝试了很多方法<br>与其琢磨一个问题都不清楚的问题<br>考虑能否绕过也是一种解决思路</p>
<hr>
<h2 id="二、绕过证书效验"><a href="#二、绕过证书效验" class="headerlink" title="二、绕过证书效验"></a>二、绕过证书效验</h2><h3 id="1-Xposed-JustTrustMe"><a href="#1-Xposed-JustTrustMe" class="headerlink" title="1. Xposed + JustTrustMe"></a>1. <code>Xposed</code> + <code>JustTrustMe</code></h3><p><code>Xposed</code>在雷电商店中直接安装上即可<br><code>JustTrustMe</code>会放在在本文末尾的附件中</p>
<p>安装完成后重启模拟器</p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173355760.png" class="" alt="image-20221010173355760">

<h3 id="2-关键数据抓不到"><a href="#2-关键数据抓不到" class="headerlink" title="2.关键数据抓不到"></a>2.关键数据抓不到</h3><p>此时再使用wifi代理的方式<br>可以发现不再提示证书错误<br>然而尝试抓app的数据<br>却发现部分关键数据抓不到</p>
<h3 id="3-第三方网络库"><a href="#3-第三方网络库" class="headerlink" title="3.第三方网络库"></a>3.第三方网络库</h3><p>APP在使用第三方网络库<br>像<code>retrofit</code> <code>okhttp</code> <code>asychttpclint</code>时<br>是不走系统代理的</p>
<h3 id="4-为何不用-Wireshark"><a href="#4-为何不用-Wireshark" class="headerlink" title="4.为何不用 Wireshark"></a>4.为何不用 <code>Wireshark</code></h3><p><code>Wireshark</code> 中分析 <code>https</code> 不仅需要复杂的设置<br>而且远不及 <code>web debug</code> 类工具清晰</p>
<hr>
<h2 id="三、最终方案"><a href="#三、最终方案" class="headerlink" title="三、最终方案"></a>三、最终方案</h2><p><code>fiddler</code> + <code>Proxifier</code> + <code>雷电</code> + <code>Xposed</code> + <code>JustTrustMe</code></p>
<p><code>Proxifier</code> 在某些特别的方面能发挥妙用<br>其原理并不复杂：<br>将原有的协议包装成 <code>http/s</code> <code>socks5</code> 等转发到代理服务器</p>
<p>在 <code>Proxifier</code> 中设置好代理服务器及规则即可<br>默认的放行</p>
<img src="/2019/12/16/android_app_protocol_analysis/image-20221010173426410.png" class="" alt="image-20221010173426410">

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发现问题后解决之<br>循序渐进<br>提炼总结</p>
<hr>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><code>JustTrustMe</code>是一个开源项目<br><strong>注意，原开源项目中的 Release 并不是最新编译</strong></p>
<p>该附件来自看雪论坛</p>
<img src="/2019/12/16/android_app_protocol_analysis/4289405131.rar" class="" alt="4289405131">]]></content>
      <tags>
        <tag>android protocol_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器设计与实践</title>
    <url>/2022/10/11/compiler_design_practice/</url>
    <content><![CDATA[<hr>
<p><strong>作为程序员，谁能拒绝徒手撸一个编译器呢？</strong> 😄</p>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近段时间一直在做《从0开始的编译器实现》，也算是趟了一遍坑。<br>遂撰文记录一下，希望能给有想法接触这方面的人提供一点帮助。</p>
<blockquote>
<p><em>Q: 有人曾问我，做这种东西有什么意义，直接去学 <code>llvm</code>，搞搞 <code>flex</code> <code>bison</code> <code>yacc</code> 它不香吗？</em></p>
</blockquote>
<blockquote>
<p><em>A: 我想了很多，不知如何回答，也许仅仅是有趣🤔？</em></p>
</blockquote>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>教学用编译器往往经过精心的简化，从而将其中一些复杂隐藏起来，<br>而一个可用的编译器则需要考虑很多的因素，复杂度也会指数上升。</p>
<p>本文将结合一些小型c语言编译器来聊这个话题，<br>参考了诸如 <code>8cc</code> <code>9cc</code> <code>chibicc</code> <code>picoc</code>  <code>ucc</code> 等。</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>通常来说，编译器会明确的分为前端、优化器、后端三个部分。</p>
<img src="/2022/10/11/compiler_design_practice/image-20221010232651279.png" class="" alt="image-20221010232651279">

<p>就实践经验来看，这三大部分实际上相当耦合。如果一开始就考虑了这种分层的设计，则后续编码过程中必将产生大量冗余和性能上的考量。<br>除非是有很大的精力，否则不推荐在自研编译器中使用<strong>分层的编码方式</strong>，这部分的取舍会相当困难。</p>
<p>一个源文件到目标程序的大致流程如下：</p>
<ol>
<li>初始化编译器上下文环境</li>
<li>读取源文件</li>
<li>通过词法分析器提取词素</li>
<li>通过语法分析器辨别语法上的正确性，构造语法树</li>
<li>通过语义分析器辨别语法树语义合理性，提炼符号信息(偏移或对齐等)</li>
<li>通过语法树构造 <code>IR(SSA)</code> 及 <code>CFG</code>（常量折叠，值编号，强度消弱，代数简化和重结合等）</li>
<li>基于 <code>IR</code> <code>CFG</code> 的优化（窥孔优化，代码消除，跳转优化等）</li>
<li>目标代码生成</li>
<li>目标程序生成</li>
<li>释放编译器上下文</li>
</ol>
<p>这里面又实际上隐含了几大必要的系统，内存分配系统，符号系统，类型系统，日志系统。</p>
<h2 id="内存分配系统"><a href="#内存分配系统" class="headerlink" title="内存分配系统"></a>内存分配系统</h2><p>一个有益的内存分配系统当然是能自行管理生命周期并防止内存无限膨胀。<br>这在编译器设计中是极其困难的，<br>除非在设计初期就能充分知道各个结构体的实现细节，既每一个结构体在何时消费掉。<br>由于结构体内部的信息本身错综复杂，若简单的采用实时释放策略，<br>会不可避免的产生大量的拷贝。</p>
<p>举例说明：<br>在获取到某个 <code>token</code> 后，通常只有部分信息(常量信息，位置信息等)对语法树的构造提供帮助，<br>如果是一个实时释放的内存系统，通过拷贝这部分有效信息可以减小内存开销。</p>
<p>而如若将宏这类预处理信息作为词法的一部分，则还需要记录对应的宏所对应的 <code>token</code> 流。<br>另外，在一些复杂的语言中，也有前看多个 <code>token</code> 的需求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	Foo(Self) &#123;</span><br><span class="line">		Self = new(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line">		Self-&gt;x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Self;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		Bar(Self) &#123;</span><br><span class="line">			<span class="comment">// .....</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">	Foo.Bar *p = Foo.Bar.Bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上述情况简记为 <code>S.S</code> 与 <code>S.S.F</code>，在这类场景中，为了获知 <code>S.S</code> 是否会成为 <code>S.S.F</code> 需要不断的前看。<br>最终它们会分别走向<code>声明</code>和<code>函数调用</code>流程。<br>当然，上述问题也能通过改善语法来解决，问题也会简化成<code>空间与时间</code>的取舍。</p>
<p>回到内存池的话题，如果仅使用<code>freelist</code>这类池来处理，<br>会不可避免的遇到预分配大小与空间浪费的问题。<br>所以采取一种混合式的池将会是自研编译器时的首要目标。<br>既要满足 <code>动态向量</code> <code>动态字符串</code> 等数据结构，又要满足一些<code>常驻信息</code>。</p>
<p>在实践中，我使用了一种类 <code>Stack-based Allocators</code> 分配策略实现一级分配器，<br>而后在其上构建出<code>freelist</code>的二级分配器。<br>当然，这并非最佳策略，只是实践上的妥协。</p>
<h2 id="符号系统"><a href="#符号系统" class="headerlink" title="符号系统"></a>符号系统</h2><p>通常来说，符号系统是为每个标识符附加一定的属性信息，<br>包括有类型信息，符号自身的作用域信息，不可写或静态等。</p>
<p>当某个符号是成员或参数时，则还需要知道该符号对应的成员或参数的信息，<br>包括了位域或偏移等。</p>
<p><code>ucc</code> 实现中，在转换阶段，符号还将作为 <code>IR</code> 的一部分存在，<br><code>tmp</code>(SSA 的临时名) 和 <code>const</code> 都会成为符号的一种。</p>
<p>函数名，记录名(结构体，联合体)，类型别名，是否都存在于同一个符号表取决于语言本身的设计。<br>例如 c 语言中，记录名是独立的符号名，而 类型别名 与 变量名 位于同一符号表中。</p>
<p>一个典型的符号结构设计如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">symbol</span> &#123;</span></span><br><span class="line">Token id; <span class="comment">// 符号名</span></span><br><span class="line">Type ty; <span class="comment">// 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ref; <span class="comment">// 被引用次数</span></span><br><span class="line"><span class="type">int</span> is_const;  <span class="comment">// 是否是常量</span></span><br><span class="line"><span class="type">int</span> is_static; <span class="comment">// 是否是静态</span></span><br><span class="line"><span class="type">int</span> is_type;   <span class="comment">// 是否是类型</span></span><br><span class="line"><span class="type">int</span> is_def;    <span class="comment">// 是否被定义</span></span><br><span class="line"></span><br><span class="line">Scope in_scope; <span class="comment">// 所在作用域</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">int</span> va_off; <span class="comment">// 全局偏移或栈偏移</span></span><br><span class="line"><span class="type">int</span> pc_off; <span class="comment">// 函数的指令偏移</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">Enum e;</span><br><span class="line">Field f;</span><br><span class="line">Param p;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>类型系统想要尽可能的包含 <code>2^n</code> 长度的数据。</p>
<p>通常会有如下基础类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空类型</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类型</span></span><br><span class="line">any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数类型</span></span><br><span class="line">i8 i16 i32 i64 isz u8 u16 u32 u64 usz</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实数类型</span></span><br><span class="line">f32 f64</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型</span></span><br><span class="line">ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">union</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 枚举类型</span></span><br><span class="line"><span class="class"><span class="title">enum</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 函数类型</span></span><br><span class="line"><span class="class"><span class="title">fn</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 标签类型</span></span><br><span class="line"><span class="class"><span class="title">label</span></span></span><br></pre></td></tr></table></figure>
<p>其中每种类型都有一个大小，代表其占用的字节数，<code>fn</code> <code>void</code> 通常为1，这是为了便于做指针的数学运算。</p>
<p>默认类型，在现有语言中通常会被设计为 <code>i32</code>，一个32位长度的有符号类型。<br>对于弱类型系统来说，比较的典型的 <code>lua</code> 则会将所有数据置于一个 <code>double</code> 中。</p>
<p>c语言的类型系统背负了历史包袱，其本身就比较复杂，<br>主要体现在 <code>unsigned</code>、<code>long</code> 关键字及函数、数组等方面，<br>对于语法分析来说，它们并不友好。</p>
<p>就函数来说，若不涉及指针相关问题，<br>使用诸如 <code>rust</code> 或 <code>golang</code>流的 <code>fn</code> 关键字会更加优雅。</p>
<p>作为c语言灵魂的指针，如果使用了 <code>fn</code> 关键字，则会引入其它方面的不便利。</p>
<p>在c语言中，指针数组，函数指针，函数指针数组…，解析起来相对复杂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">T id;</span><br><span class="line">T (*(*id));</span><br><span class="line">T (*id)[];</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T, T)</span>;</span><br><span class="line">T (*id)(T, T);</span><br><span class="line">T (*id[])(T, T);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>而函数的声明和定义则更进一步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">id</span><span class="params">(T, T)</span>;</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T id, T id)</span>;</span><br><span class="line">T <span class="title function_">id</span><span class="params">(T id, T id)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你必须在完整解析整个声明部分之后才能确定主 <code>id</code> 到底是什么类型。</p>
<p>以上仅是冰山一角，接下来，还会面对另一个严肃的问题，类型兼容与类型转换。</p>
<p>很多情况下，编译器都需要判断出两个类型是否兼容，或者是否合理。</p>
<p>对于c语言这种不纯粹的强类型语言来说，隐式类型转换会发生的更加频繁。<br>这是一个让人又爱又恨的机制，它很容易让人犯错，但也很方便，<br>没有人希望顶着一堆类型转换写完代码，除非你压根不知道自己在写什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">1.0f</span>;</span><br><span class="line"><span class="number">2</span> + (<span class="type">int</span>*)<span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在进行表达式语义分析时，编译器作者不得不一遍又一遍的比较左右子树的类型，为其添加对应的转换过程。<br>同时这个转换过程还会受到一些限制，比如 <code>+-</code> 的两边不能都是指针，但其中一边可以是指针，<br>位运算则要求必须是整数，逻辑运算则要求两边都是可计算的类型等等。</p>
<p>除此之外，类型系统还有另一个复杂点，函数名，数组名，标签名在表达式中会退化为一种特别的指针类型。<br>例如对函数名取值、取地址操作得到的依旧函数本身的偏移值，即源函数指针。<br>而对数组名取值会取到一个元素。标签名则不允许取值操作，同样也不应参与运算。<br>对于<code>gcc</code> 这种 <code>label as value</code> 的机制则需要更多的处理。</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>日志系统从表面上看，只是一个用于打印输出的模块，但实际的内容会比一眼看上去的多。</p>
<p>首先一个好的编译器日志系统不仅要能辅助编译器实现，即报出编译器自身的异常信息和调试信息，同时也应用于输出编译过程中的警告错误等。</p>
<p>一个典型的编译错误日志如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a b</span><br><span class="line">------^</span><br><span class="line"></span><br><span class="line">[main.c:<span class="number">1</span>] error: expect <span class="string">&#x27;;&#x27;</span> but got <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于编译自身日志，可以和普通的打印一致，立即输出到屏幕，而对于编译日志则需要更多的工作。<br>一方面，需要打印错误的代码位置，方便语言使用者定位问题。<br>另一方面，还需要考虑到错误恢复机制带来的影响，即不是所有的 <code>err</code> 日志都能立即退出。<br>如果编译器本身被嵌入了复杂的系统环境中，则不一定支持立即退出这种一劳永逸的办法，而是应该在统一的出口处报错。</p>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>纯手写词法分析器并不困难，值得注意的只有以下几点：</p>
<ol>
<li>常量字面量类型处理</li>
<li>转义字符</li>
<li>保留字识别</li>
<li>ch 前看支持</li>
<li>token 前看支持</li>
</ol>
<ul>
<li><p><strong>常量字面量</strong> 存在有前后缀问题，需要注意。且对于<code>??.??.??</code> 或 <code>0x??.??</code> 也需要进一步处理。</p>
</li>
<li><p><strong>转义字符</strong> 需要获取转义值。</p>
</li>
<li><p><strong>保留字</strong> 则和标识符的处理逻辑共用，通常是获取标识符后，判断该标识符是否是保留字。</p>
</li>
<li><p><strong>ch 前看支持</strong> 在解析诸如 <code>++</code> <code>+=</code> <code>\n</code> …。</p>
</li>
<li><p><strong>token 前看支持</strong>：<br>c语言语法中强制类型转换是较为特别的存在，<br><code>(T)</code> 或 <code>(id)</code> ，<br>对比上述两者，前者为强制类型转换，<br>后者则是普通的表达式主语。<br>故为了识别出具体是哪种，需要前看支持。<br>在支持 <code>S.S.F</code> 的编译器中，这一问题会变得更为复杂，例如 <code>c++</code> 的静态成员函数等。</p>
</li>
</ul>
<p>编译器设计初期就应为上述问题提供一个合理的方案，包含但不局限于此。</p>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>自研编译器中，可以把语法分析和语义分析放到一个趟中处理。</p>
<p>语法分析器只表明语法上是否合规，基本是一套固定的逻辑。<br>通常会采用<code>递归下降的语法分析器</code>，也有像 <code>c4</code> 那种特别定制的分析器。</p>
<p>这一部分可以直接对照语法实现，在各类编译器书籍中出现较多。</p>
<p>对于c语言来说，最复杂的部分是 <code>ExternalDeclaration</code>，其中牵扯声明定义，导出静态，常量…需要尤其注意。</p>
<p>另外在关于 <code>Ast_Node</code> 结构的选型上，不同编译器采用了不同的形式。<br>例如 <code>ucc</code> 中会为不同的语句等设计独立的 <code>node</code> 结构，将所有的<code>二元``一元</code>规整到一起设计一个通用结构。<br>在 <code>chibicc</code> 中，则全部使用一个通用结构，其内部可以用联合体优化。</p>
<p>二者只能说各有千秋，前者的问题在于需要更多的强制类型转换才能将所有的节点串到一起，<br>后者的问题则是编写过程中很容易搞混。</p>
<p>如果语法分析和语义分析器是独立的，则在处理<code>初始化列表</code>时会增加一定难度。</p>
<p>如果二者是融合的，则以常量表达式及常量折叠入手编写会更加容易。<br>当然，融合实现时，代码也会更加复杂，</p>
<h2 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h2><p>自研编译器中，若采用独立的语义分析器，则语法分析部分不考虑语义问题。</p>
<p>语义分析阶段，除去检查符号重定义或类型声明及语句的合法性外，还应检查类型是否兼容等问题。</p>
<p>该阶段要为每一个表达式的节点确定类型，同时还需要确定其是否是左值，是否可写，是否为常量等等。</p>
<p>符号表的建立也会发生在该阶段，<br>需要特别注意的是，在部分情况下(函数声明时的参数检查，<code>record</code>类型的成员检查)，符号只应检查是否在当前作用域发生重定义。</p>
<p>变量的偏移值可以在其定义时获取，没有初始化定义的变量都可以被简化成一个偏移值，即可消除掉对应的节点 。</p>
<p>初始化列表是否匹配也发生在该阶段，需要处理各种可能的情景。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[][2] = &#123;&#123;1,2&#125;, 2, 3, 4, &#123;5,6&#125;&#125;;</span><br><span class="line">int b = &#123;&#123;0&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果涉及 <code>goto</code>，按照 <code>clang</code> 的结论是会重复执行初始化赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__foo:</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> __foo;</span><br></pre></td></tr></table></figure>

<p>对于位域问题和匿名 <code>record</code> 内嵌问题，对齐问题，也都需要一一处理。</p>
<p>例如位域是否应该采取紧凑型，又或者是否应该支持 <code>int:31</code> 这类场景，还有一些不能对位域取地址限制的检查。</p>
<p>大部分常量折叠也会发生在这一阶段。</p>
<p>例如 <code>int a[1+1]</code> ，<code>1+1</code> 需要被折叠以确定 <code>[]</code> 中是一个大于等于零的整数。<br>同时常量指针也应参与折叠过程 <code>0+(void*)0</code>。</p>
<h2 id="IR-生成"><a href="#IR-生成" class="headerlink" title="IR 生成"></a>IR 生成</h2><p>SSA IR 是一种比起语法树更简洁的表现形式，在其基础上优化会更容易。<br>同时生成过程中也可以完成一些前期优化工作，收集必要信息，构造控制流图等。</p>
<h3 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h3><p>在逻辑与算法生成短路现象时，会将 <code>&amp;&amp;</code> 的左右拆开，生成条件跳转，这会在原来的节点上填充新的算术节点。<br>对于会填充新算术节点的情况就需要再次进行常量折叠。</p>
<h3 id="强度消弱"><a href="#强度消弱" class="headerlink" title="强度消弱"></a>强度消弱</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = i * 7</span><br><span class="line">-&gt;</span><br><span class="line">t = i &lt;&lt; 3</span><br><span class="line">t = t - i</span><br></pre></td></tr></table></figure>

<h3 id="代数简化和重结合"><a href="#代数简化和重结合" class="headerlink" title="代数简化和重结合"></a>代数简化和重结合</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a*1 = a</span><br><span class="line">a/1 = a</span><br><span class="line">a+0 = a</span><br><span class="line">a-0 = a</span><br><span class="line">-(-a) = a</span><br><span class="line">i + (-a) = i-a</span><br><span class="line">*(&amp;p) = p</span><br><span class="line">(&amp;q)-&gt;s = q.s</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="值编号"><a href="#值编号" class="headerlink" title="值编号"></a>值编号</h3><p>值编号是判断两个计算是否等价并删除其中之一的一种办法。<br>为 op src dst 计算一个hash，判断该计算是否已经生成变量 t，<br>判断 t 是否位于当前基本块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int b,x;</span><br><span class="line">//</span><br><span class="line">int a = b + 1;</span><br><span class="line">int c = b + 1 + x;</span><br><span class="line"></span><br><span class="line">IR:</span><br><span class="line">t0 = b + 1</span><br><span class="line">a = b</span><br><span class="line">t1 = t0 + x  ; 这里就发生了简化，不再生成 b+1 的计算</span><br><span class="line">c = t1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 src dst 发生改变时，其对应的值编号将不能再被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = b + 1;</span><br><span class="line">int c = b + 1 + x</span><br><span class="line"></span><br><span class="line">IR:</span><br><span class="line">t0 = b + 1</span><br><span class="line">b = t0</span><br><span class="line">t1 = b + 1    ; 不能简化</span><br><span class="line">t2 = t1 + 1</span><br><span class="line">c = t2</span><br></pre></td></tr></table></figure>

<p><strong>限于篇幅，本文只举出几个简单的例子，后面有机会再摊开说明</strong>。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><h3 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 移除无用的 MOV</span><br><span class="line">CALL t0 foo (...)</span><br><span class="line">MOV  a, t0</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">CALL a foo (...)</span><br><span class="line"></span><br><span class="line">// 移除无用的 MOV</span><br><span class="line">ADD t0 &lt;- b 1</span><br><span class="line">MOV b  &lt;- t0</span><br><span class="line">--&gt;</span><br><span class="line">ADD b &lt;- b 1</span><br><span class="line"></span><br><span class="line">// 优化指令</span><br><span class="line">ADD b &lt;- b 1</span><br><span class="line">-&gt;</span><br><span class="line">INC b</span><br></pre></td></tr></table></figure>

<p>窥孔优化即根据几条相邻的指令内容简化指令，除了基于 IR 的优化外，还可以在代码生成阶段，根据目标平台指令，进一步优化。</p>
<h3 id="变量消除"><a href="#变量消除" class="headerlink" title="变量消除"></a>变量消除</h3><p>移除未引用的临时变量</p>
<h3 id="跳转消除"><a href="#跳转消除" class="headerlink" title="跳转消除"></a>跳转消除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp lab0</span><br><span class="line"></span><br><span class="line">lab0:</span><br><span class="line">jmp lab1</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">jmp lab1</span><br></pre></td></tr></table></figure>

<h3 id="合并基本块"><a href="#合并基本块" class="headerlink" title="合并基本块"></a>合并基本块</h3><p>移除没有指令的基本块或将跳转消除后的基本块合并。</p>
<h3 id="死码消除"><a href="#死码消除" class="headerlink" title="死码消除"></a>死码消除</h3><p>遍历控制流图，仅保留可达的基本块。</p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h3><p>将无限的虚拟寄存器映射到有限的真实寄存器的过程。<br>一种常用的方案是图着色分配方法，由 构造、简化、溢出、选择 四个主要阶段构成。<br>在 《高级编译器设计与实现》《现代编译原理：c语言描述》等书中有细致的描述。</p>
<p><strong>后面有时间再单独结合代码聊一下这个</strong>。</p>
<h3 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h3><p>略，这个我还没搞明白，自研编译器鲜有实现到这里的。<br>大概意思是调度重排指令，使其能更好利用目标处理器的流水线。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="基于栈还是寄存器"><a href="#基于栈还是寄存器" class="headerlink" title="基于栈还是寄存器"></a>基于栈还是寄存器</h3><p>对于虚拟机本身来说二者区别实际上不大。<br>对于编译器来说，更容易生成高质量的寄存器虚拟机指令。</p>
<p>栈式虚拟机在栈上产生的值需要额外的弹出操作，<br>虽然也可以优化，但我了解不多。</p>
<h3 id="类型表示"><a href="#类型表示" class="headerlink" title="类型表示"></a>类型表示</h3><p>虚拟机在计算时，仍旧需要关注类型及类型转换。<br>有符号与无符号，实数与整数等运算都有涉及。</p>
<h3 id="虚拟机交互"><a href="#虚拟机交互" class="headerlink" title="虚拟机交互"></a>虚拟机交互</h3><p>虚拟机应提供中止或打断的介入能力，以用于监视其执行过程。<br>同时也应该能有效的调用外部函数，拥有类似 <code>dyncall</code> <code>libffi</code> 的功能。<br>当虚拟机内部函数被作为回调函数传送到外部时，应使用某种识别机制以包装该函数。<br>多线程情况下的资源协调与同步问题。</p>
<h2 id="解析交互模式"><a href="#解析交互模式" class="headerlink" title="解析交互模式"></a>解析交互模式</h2><p>开始确实有引入交互模式的想法，但是后来发现错误回滚方面有着<strong>巨大的代价</strong>，同时不能很好的融入编译模式。<br><code>picoc</code> 在这方面提供了很好的参考，虽然它也未能很好的解决错误回滚问题，也许需要一个更好的内存分配系统和一个更好的内存快照机制才能解决。</p>
<p>综上，实现的价值太低，代价又太大，遂放弃。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合我数月的实践经验，简单聊了一下自研编译器时会遇到各种问题。<br>文中很多地方没有使用规范的术语，而且只是从实践的角度进行片面的描述。<br><strong>实践并不代表符合编译器设计的各种规范</strong>。</p>
<p>从 <code>8cc</code> 到 <code>9cc</code> 再到 <code>chibicc</code>，可以看到作者的一路征程。<br>同样的 <code>ucc</code> 是我认为写的比较完善的小型c编译器之一了，<br>其中也存在着很多的 <code>bug</code>。<br>一个完善的c编译器，只能说非常难。<br>可以想象 <code>c++</code> 编译器得复杂到何种程度。</p>
<p>文中还有很多很多没有写到的地方，比如类型推导之类。<br>回过头再看，其实有很多更好的实践方案。很多地方都是时间上的妥协。</p>
<h2 id="碎语"><a href="#碎语" class="headerlink" title="碎语"></a>碎语</h2><p>这几个月，前后推翻重写了6，7次，才写出一个相对可用的框架。<br>目前也才实现到了<code>IR 生成</code>一小部分。</p>
<p>总之，钱烧完了，得去找工作了😄。<br>之后也会持续更新本文，为实现一个真正可用的编译器而努力💪。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/rui314/chibicc">GitHub - rui314&#x2F;chibicc: A small C compiler</a></li>
<li><a href="https://github.com/rui314/8cc">GitHub - rui314&#x2F;8cc: A Small C Compiler</a></li>
<li><a href="https://github.com/rui314/9cc">GitHub - rui314&#x2F;9cc: A Small C Compiler</a></li>
<li><a href="https://github.com/nobled/ucc">GitHub - nobled&#x2F;ucc: ucc - a tiny C89 compiler for x86</a></li>
<li><a href="https://gitlab.com/zsaleeba/picoc">Zik Saleeba &#x2F; picoc · GitLab</a></li>
</ul>
]]></content>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>巧用DLL劫持做黑盒分析</title>
    <url>/2019/12/17/dll_hook/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前因需分析某加了SE壳的易语言程序。</p>
<h2 id="从哪里入手"><a href="#从哪里入手" class="headerlink" title="从哪里入手?"></a>从哪里入手?</h2><p>对于这种加了vmp壳<br>而分析价值又不高的目标<br>首先想到的不应是如何还原<br>而是通过黑盒方式分析其原理</p>
<p>当然这种方式对于纯粹的算法程序就无计可施了</p>
<p>该程序文件结构如下:</p>
<blockquote>
<p>程序.exe<br>v8.dll</p>
</blockquote>
<p>一般来说<br>易语言程序很少会调用dll<br>从名字上看 <code>v8.dll</code> 的作用是为了让程序能跟 <code>js</code> 交互</p>
<img src="/2019/12/17/dll_hook/image-20221010175922346.png" class="" alt="image-20221010175922346">

<p>在IDA中查看导出表也能很快验证之前的猜想</p>
<p>那么目标就确定了<br>虽然不能很快的分析源程序<br>但是可以较为容易的获得 <code>ExecJavaScriptV8</code> 的参数<br>从而得到一些便于分析的内容</p>
<h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>原理说起来也很简单<br>通过伪造一个 <code>v8.dll</code>替换掉原 <code>v8.dll</code><br>然后在 新<code>v8.dll</code>中将所有导出函数转回 原<code>v8.dll</code></p>
<p>那么就可以在源码层面去控制导出函数了<br>这种方式可能会被<code>文件效验</code>的方式检测</p>
<p>本程序中不存在<code>文件效验</code><br>本文也不打算讲如何绕过<code>文件效验</code></p>
<p>此时新的文件结构应如下:</p>
<blockquote>
<p>程序.exe<br>v8.dll<br>v8Org.dll</p>
</blockquote>
<hr>
<h2 id="AheadLib"><a href="#AheadLib" class="headerlink" title="AheadLib"></a>AheadLib</h2><p>要生成一个转发dll<br>最快的方式莫过于使用 <code>AheadLib</code></p>
<p>其中<code>AheadLib</code>存在两个常见的版本</p>
<img src="/2019/12/17/dll_hook/image-20221010175954304.png" class="" alt="image-20221010175954304">

<p>本文这个 <code>v8.dll</code> 是一个复杂的 <code>c++</code> 程序<br>在<code>AheadLib-x86-x64</code> 直接拖入会崩溃</p>
<p>在<code>AheadLib +</code>中没有什么问题<br>只是在生成<code>即时调用</code>时<br>生成的代码有问题</p>
<p>如果可以直接生成<code>即时调用</code><br>那本文也就到此结束了</p>
<p>另外<code>AheadLib-x86-x64</code>生成的代码框架要优于<code>AheadLib +</code></p>
<p>这里我采用的方法是用<code>AheadLib +</code> 先生成一份 <code>v8Org.cpp</code><br>编译之<br>得到一个新的 <code>v8.dll</code><br>再将刚刚生成的<code>v8.dll</code>拖入<code>AheadLib +</code><br>如此一来便可得到新的 <code>v8.cpp</code><br>由于生成的代码是使用的 <code>pragma</code> 预处理指令进行转发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;xxxx&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>故用 <code>新dll</code> 和 <code>原dll</code> 生成是没有区别的<br>在新代码生成后<br> <code>新dll</code>  就没用了</p>
<hr>
<h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><p>与其称之为hook，实际上就是普通的接管</p>
<img src="/2019/12/17/dll_hook/image-20221010180033825.png" class="" alt="image-20221010180033825">


<p>通过阅读load函数<br>得知需要将 <code>原dll</code> 重命名为 <code>v8org.dll</code></p>
<p>开始接管 <code>ExecJavaScriptV8</code></p>
<img src="/2019/12/17/dll_hook/image-20221010180054176.png" class="" alt="image-20221010180054176">

<p><strong>注意 <code>AheadLib_ExecJavaScriptV8</code> 是裸函数</strong><br><strong>注意 <code>/EXPORT:ExecJavaScriptV8=_AheadLib_ExecJavaScriptV8</code> 有个下划线代表是内部函数</strong></p>
<p>其中 <code>@3</code> 代表该函数有3个参数<br>实际这个函数是<code>__thiscall </code><br>但是查看参数不需要理会 <code>this</code> 指针<br>网上搜一下<br>很容易找到原型</p>
<img src="/2019/12/17/dll_hook/image-20221010180115984.png" class="" alt="image-20221010180115984">

<p>前两个参数是 <code>char*</code><br>第三个是 <code>BOOL</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* text;</span><br><span class="line"><span class="function">ALCDECL <span class="title">AheadLib_ExecJavaScriptV8</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数一</span></span><br><span class="line">  __asm &#123;</span><br><span class="line">    push[esp + <span class="number">0x8</span>]</span><br><span class="line">    pop[text]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出 text -- 省略</span></span><br><span class="line">  __asm JMP pfnExecJavaScriptV8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终<br>提取了其<code>js</code><br>及调用的相关函数<br>对后续分析提供了莫大帮助</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有时候碰到问题<br>不能看到钉子就去找锤子<br>也许你仅仅需要一块板砖</p>
]]></content>
      <tags>
        <tag>dll hook</tag>
      </tags>
  </entry>
  <entry>
    <title>ishot_crack -- OSX M1(Apple Sillcon) 逆向工程实践</title>
    <url>/2022/03/30/ishot_crack/</url>
    <content><![CDATA[<h2 id="坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。"><a href="#坚决抵制盗版行为，本文仅作-OSX-软件逆向分析及-OSX-软件安全相关的研究目的。" class="headerlink" title="坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。"></a><strong>坚决抵制盗版行为，本文仅作 OSX 软件逆向分析及 OSX 软件安全相关的研究目的。</strong></h2><span id="more"></span>

<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间遇到款相当实用的国产截图工具–ishot，大致翻看了下是<code>AppStore</code>内购。<br>正好没尝试过分析<code>AppStore</code>内购应用，遂拿起把玩一番。</p>
<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><ul>
<li>macos Monterey 12.3 (21E230) (M1)</li>
<li>iShot 2.0.7 (980)</li>
<li>IDA Pro (7.6)</li>
<li>Proxyman 3.3.0 (30300)</li>
</ul>
<h2 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h2><p>打开软件，看到有恢复购买字样，这是很好的开始。</p>
<img src="/2022/03/30/ishot_crack/0.png" class="" alt="目标">

<p>这意味着，如果软件校验不是足够复杂，只需要让其恢复购买步入正确逻辑即可达成目标。<br>即便是它不能一步到位，也能作为一个切入点。<br>用IDA打开，遵循上述逻辑，将<code>restore</code>作为关键字搜索相关函数。</p>
<img src="/2022/03/30/ishot_crack/1.png" class="" alt="restore">

<p>一眼看去，印象最深的便是<code>BuyFromAppStoreController restoreBtnClick:</code>，也就是按键对应的函数。</p>
<img src="/2022/03/30/ishot_crack/2.png" class="" alt="restoreBtnClick">

<p>简单看一下逻辑，大概就是访问网络后处理结果。<br>对应的处理函数为<code>ApplePurchaseManager restorePurchaseWithCompleteBlock:</code></p>
<img src="/2022/03/30/ishot_crack/3.png" class="" alt="restorePurchaseWithCompleteBlock">

<p>继续深入<code>restorePurchaseWithCompleteBlock</code>，最终会调用<code>restoreCompletedTransactions</code>相关函数处理。</p>
<p>搜索<code>restoreCompletedTransactions</code>。</p>
<img src="/2022/03/30/ishot_crack/4.png" class="" alt="restoreCompletedTransactions">

<p>从符号名上看<br>1.<code>paymentQueueRestoreCompletedTransactionsFinished</code>为处理成功。<br>2.<code>paymentQueue:restoreCompletedTransactionsFailedWithError</code>为处理失败。</p>
<p>通常失败逻辑比较简单的话，可以做个笔记，有助于后续分析。</p>
<img src="/2022/03/30/ishot_crack/5.png" class="" alt="restoreCompletedTransactionsFailedWithError">

<p>当调用<code>-[ApplePurchaseManager handleActionWithType:data:](self, &quot;handleActionWithType:data:&quot;, 1LL, 0LL);</code>时即为失败。</p>
<p>继续看成功部分</p>
<img src="/2022/03/30/ishot_crack/6.png" class="" alt="paymentQueueRestoreCompletedTransactionsFinished">

<p>它的功能仅仅是转入<br><code>verifyPurchaseWithPaymentTransaction:isTestServer:Compl:</code>，<br>继续深入</p>
<img src="/2022/03/30/ishot_crack/7.png" class="" alt="verifyPurchaseWithPaymentTransaction">
<p>看到一处类似<code>完成函数注册</code>的代码，对函数<code>sub_10004299D</code>需要特别关注。</p>
<p>结合上下文，可以得到一个大致流程。</p>
<ol>
<li>请求<code>https://buy.itunes.apple.com/verifyReceipt</code></li>
<li>在<code>sub_10004299D</code>处理返回数据</li>
<li>校验数据完成恢复</li>
</ol>
<h2 id="深入浅出"><a href="#深入浅出" class="headerlink" title="深入浅出"></a>深入浅出</h2><p>跟入函数<code>sub_10004299D</code>一探究竟。</p>
<img src="/2022/03/30/ishot_crack/8.png" class="" alt="sub_10004299D">

<p>其中<code>AES</code>的字样格外醒目，通常验证算法都会伴随加解密。也就是说，进到<code>AES</code>加密流程更符合猜想。<br>这里的<code>AES</code>只有一个加密部分，同样后续还需要分析解密部分。</p>
<p>之前分析过<br><code>-[ApplePurchaseManager handleActionWithType:data:](self, &quot;handleActionWithType:data:&quot;, 1LL, 0LL);</code>为失败。</p>
<p>此处可以得到一个初步结论，当参数为<code>(1,??) (3,0)....</code>为失败，<code>(4,0)</code>为成功。</p>
<p>为了能进入到<code>AES</code>算法步骤，必须让<code>sub_100048A6D(v30)</code>返回真。</p>
<p>其中<code>v30</code>来自<code>receipt</code>， 这个实际上是之前返回的数据包。</p>
<p>打开<code>Proxyman</code>验证。</p>
<img src="/2022/03/30/ishot_crack/9.png" class="" alt="response">


<p>进入<code>sub_100048A6D</code>函数</p>
<img src="/2022/03/30/ishot_crack/10.png" class="" alt="sub_100048A6D">

<p>其中<code>dbl_1000D6BF0   dq 2.6784e9, 3.1536e10</code>。</p>
<p>逻辑上一目了然。为了让返回值为1，即v34必须为1。<br>若要保持<code>v34</code>为1，也就必须让<code>v33&gt;v31</code>成立，<code>v31</code>来自<code>request_date_ms</code>(比较长没贴出)，<br><code>v34</code>为<code>purchase_date_ms</code>。</p>
<p>也就是<code>purchase_date_ms&gt;request_date_ms</code>。</p>
<p>至此恢复逻辑全部完成。</p>
<h2 id="梳理逻辑"><a href="#梳理逻辑" class="headerlink" title="梳理逻辑"></a>梳理逻辑</h2><p>之前<code>AES</code>部分只看到了加密，通过交叉引用可以定位到解密函数位于入口函数<code>start</code>中。</p>
<p>出于篇幅限制，这里就不贴代码了。简单口述一下。</p>
<p>当点击恢复按钮时，会从<code>AppStore</code>获取凭证数据并进行时间等校验，之后再将获取的数据加密保存到文件中。</p>
<p>实际上是通过<code>standardUserDefaults</code>保存，其路径为：<br><code>/System/Volumes/Data/Users/$USER/Library/Containers/cn.better365.ishot/Data/Library/Preferences/cn.better365.ishot.plist</code></p>
<p>当应用启动时，入口函数<code>start</code>根据保存的信息，解密并校验。另外试用逻辑也是在此处校验。</p>
<p>还值得一提的是<code>AES</code>的密钥是根据设备信息生成的，所以理论上这个注册文件不能直接发往其它机器。</p>
<h2 id="猜想验证"><a href="#猜想验证" class="headerlink" title="猜想验证"></a>猜想验证</h2><p>构造数据包(只保留关键部分):</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;receipt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="attr">&quot;request_date_ms&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;in_app&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;product_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;ishotfeixuqidingyue20220212&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="comment">// ....</span></span><br><span class="line">             <span class="attr">&quot;purchase_date_ms&quot;</span><span class="punctuation">:</span><span class="string">&quot;9747829370000&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>启用<code>map local tool</code></p>
<img src="/2022/03/30/ishot_crack/11.png" class="" alt="map_local">

<p>再次恢复购买</p>
<img src="/2022/03/30/ishot_crack/12.png" class="" alt="restore">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来自<code>AppStore</code>的应用的安全性实际上和传统的软件安全性一样。</p>
<p>本文中软件存在最大的问题在于轻信了<code>AppStore</code>的返回凭证而未进行二次校验，这就给了一些不法之徒可趁之机。</p>
<p>最后提一壶，<code>ishot</code>确实非常不错，建议有能力的朋友可以去支持一下这款国产软件发展。</p>
]]></content>
      <tags>
        <tag>AppStore内购 OSX M1(Apple Sillcon) 逆向工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>旧话重提 -- 同步、异步、阻塞、非阻塞</title>
    <url>/2019/12/15/network_study_0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文以大雄妈妈喊他写作业为例子展开讨论。</p>
<img src="/2019/12/15/network_study_0/image-20221010171258100.png" class="" alt="image-20221010171258100">

<hr>
<h2 id="大雄写作业"><a href="#大雄写作业" class="headerlink" title="大雄写作业"></a>大雄写作业</h2><h3 id="从大雄写作业开始–同步、异步"><a href="#从大雄写作业开始–同步、异步" class="headerlink" title="从大雄写作业开始–同步、异步"></a>从大雄写作业开始–同步、异步</h3><p>话说某天，大雄的妈妈又喊他写作业了。(<strong>调用</strong>)</p>
<p>此时，大雄会有几种反应。</p>
<ol>
<li>好的，我立马<code>做</code>。 (<strong>同步调用</strong>)</li>
<li>我待会再去<code>做</code>。  (<strong>异步调用</strong>)</li>
</ol>
<blockquote>
<p>异步本质上是一种延迟过程调用。</p>
</blockquote>
<h3 id="大雄的妈妈如何知道作业做完了没有–阻塞、非阻塞"><a href="#大雄的妈妈如何知道作业做完了没有–阻塞、非阻塞" class="headerlink" title="大雄的妈妈如何知道作业做完了没有–阻塞、非阻塞"></a>大雄的妈妈如何知道作业做完了没有–阻塞、非阻塞</h3><ol>
<li>大雄的妈妈坐在旁边等。 (<strong>阻塞</strong>)</li>
<li>大雄的妈妈每隔一段时间过来看一下。 (<strong>非阻塞</strong>)</li>
</ol>
<h3 id="大雄的妈妈如何知道作业做完了没有–完成函数"><a href="#大雄的妈妈如何知道作业做完了没有–完成函数" class="headerlink" title="大雄的妈妈如何知道作业做完了没有–完成函数"></a>大雄的妈妈如何知道作业做完了没有–完成函数</h3><p>我们看出来了，上面两种方式都不是很好，其实大雄的妈妈只需要告诉大雄，你做完作业来通知我。<br>这个做完并通知的函数即<code>完成函数</code>。</p>
<hr>
<h2 id="在现代分时操作系统中讨论"><a href="#在现代分时操作系统中讨论" class="headerlink" title="在现代分时操作系统中讨论"></a>在现代分时操作系统中讨论</h2><h3 id="在现代分时操作系统中谈IO"><a href="#在现代分时操作系统中谈IO" class="headerlink" title="在现代分时操作系统中谈IO"></a>在现代分时操作系统中谈IO</h3><p>以上例子对于字面解释来说是正确的，但是在IO的情况下有些容易被忽视的细节:<br><code>IO本质上是异步的</code><br>例如在调用<code>read</code> <code>write</code>等，他们所作的事情不过是将<code>io任务</code>送到<code>io任务队列</code>中(具体底层实现不一定是队列，这里只是为了方面描述)，等待进一步处理。<br>如果<code>fd</code>处于阻塞模式，将通过<code>事件</code> <code>信号</code>等方式等待 <code>io操作完成</code>，反之亦然。</p>
<p>对于大多数上层开发者来说，他们只关心到:<br><strong>大雄妈妈喊大雄写作业这一层面，而不具体去关心大雄到底是如何写作业。</strong><br><strong>如果放在现代分时操作系统层面来说，得到结果就是<code>大雄可能就没有亲自去做过作业</code>。</strong></p>
<p>为何要加<code>现代分时</code>几字，在原始的系统或者实时系统中 IO调用就是一头摸到黑，直接去读写硬件的IO端口，这种就不作讨论。</p>
<h3 id="在在现代分时操作系统中谈完成端口"><a href="#在在现代分时操作系统中谈完成端口" class="headerlink" title="在在现代分时操作系统中谈完成端口"></a>在在现代分时操作系统中谈完成端口</h3><p>完成端口的首要条件就是异步(要是同步的,函数调用返回的时候就知道结果了)，根据之前的说法，<code>IO本质上是异步的</code>，也就是说，无论哪个系统都是可以写出完成端口的，区别也仅在于内核封装以系统调用的形式提供，还是由上层(应用层)封装以库接口的形式提供。</p>
<p>上层封装又会出现各种开销等问题，肯定是不如内核封装来的好。</p>
<p>在此简单聊几句 windows上原装的完成端口:<br>完成端口的<code>GetQueuedCompletionStatus</code>内部是一个带锁队列。<br>其内存放着已经完成的IO请求及附属结构。每次调用时都会弹出队列顶部的<code>I/O completion packet</code>。<br>这个东西并不复杂，只是<code>windows完成端口(IOCP)</code>还存在一些棱模两可(缺乏相关文档解释说明)的东西，用的时候很坑。</p>
<h3 id="完成端口与多路复用"><a href="#完成端口与多路复用" class="headerlink" title="完成端口与多路复用"></a>完成端口与多路复用</h3><p>从浅显的层面说明，注意下文提及的系统方和调用方均位于内核层<br><strong>windows完成端口:</strong><br>系统方 : IO操作完成时(包括拷贝)，加入完成队列<br>调用方 : 从完成队列取出<code>I/O completion packet</code>并返回，没有时等待</p>
<p><strong>多路复用:</strong></p>
<ol>
<li><p>select、poll<br>系统方 : 能IO操作时，设置相关标识<br>调用方 : 轮询所有fd的IO标识，碰到相关标识为相关事件时返回，没有时等待</p>
</li>
<li><p>epoll<br>系统方 : 能IO操作时，加入就绪队列<br>调用方 : 取回就绪队列内容，没有时等待</p>
</li>
</ol>
<p><strong>小结:</strong><br>从效率上说，完成端口直接往提供的 buffer 中写入数据，要比多路复用少一次系统调用，<br>代价是灵活性以及buffer开销(因为需要预先分配一个足够大的buffer，否则得不偿失)</p>
<blockquote>
<p>具体可参见 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsock2/nf-winsock2-wsarecv">WSARecv 函数 (winsock2.h) - Win32 apps | Microsoft Learn</a> 有关 WSAEMSGSIZE 的说明</p>
</blockquote>
<p>同时在多路复用中，epoll 又相对于 select、poll 少了一个轮询过程。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键是要明白，所谓的 同步、异步、阻塞、非阻塞到底是在哪个层面去说的，否则容易出现理解偏差。</p>
<hr>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在上次讨论本话题时，是对着内核源码多角度分析的，而本文仅凭回忆及一些片面的参考资料作出。<br>这也导致了本文描述的不够细致，难免出现错误，如果有什么错误欢迎留言指出。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/gaorong/p/7496993.html">epoll全面讲解：从实现到应用 - gaorong404 - 博客园</a></li>
<li><a href="https://www.jianshu.com/p/397449cadc9a">IO多路复用的三种机制Select，Poll，Epoll - 简书</a></li>
</ul>
]]></content>
      <tags>
        <tag>network IOCP</tag>
      </tags>
  </entry>
  <entry>
    <title>nt驱动开发(0)--复习</title>
    <url>/2020/03/10/nt_driver_0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在找工作，很久没有碰驱动的缘故，略生疏，遂复习一番。</p>
<h2 id="驱动开发汇总"><a href="#驱动开发汇总" class="headerlink" title="驱动开发汇总"></a>驱动开发汇总</h2><h3 id="1-什么是驱动程序"><a href="#1-什么是驱动程序" class="headerlink" title="1.什么是驱动程序?"></a>1.什么是驱动程序?</h3><p>由应用层驱动，位于内核层与硬件设备打交道或对内核产生一定影响的程序称为驱动程序。</p>
<h3 id="2-什么是驱动对象"><a href="#2-什么是驱动对象" class="headerlink" title="2.什么是驱动对象?"></a>2.什么是驱动对象?</h3><p>一个驱动程序的实例称为驱动对象，其在驱动程序加载时由对象管理器创建。<br><code>IoCallDriver</code> 调用驱动</p>
<h3 id="3-什么是设备对象"><a href="#3-什么是设备对象" class="headerlink" title="3.什么是设备对象?"></a>3.什么是设备对象?</h3><p>设备对象保存设备特征和状态，在设备驱动程序中存在一个或多个设备对象。<br>另外在设备对象结构 _DEVICE_OBJECT 中存在 DeviceExtension , 其作用类似于重叠结构。<br><code>IoCreateDevice </code>              &#x2F;&#x2F; 创建一个设备<br><code>IoCreateDeviceSecure</code>         &#x2F;&#x2F; 同上，并支持任何用户直接打开设备字符，降低权限要求<br><code>IoGetDeviceObjectPointer</code>     &#x2F;&#x2F; 获取设备对象指针，会增加一个引用计数<br><code>IoAttachDeviceToDeviceStack</code> &#x2F;&#x2F; 挂载设备对象到设备栈<br><code>IoDetachDevice</code>              &#x2F;&#x2F; 卸载设备对象</p>
<h3 id="4-驱动对象与设备对象的关系"><a href="#4-驱动对象与设备对象的关系" class="headerlink" title="4.驱动对象与设备对象的关系?"></a>4.驱动对象与设备对象的关系?</h3><p>一个驱动对象可以管理多个设备对象，<br>在派遣函数中，可以根据不同的设备对象做不同的处理，<br>另外与该设备相关的信息可以放在其扩展域中 <code>DeviceExtension</code>。</p>
<h3 id="5-几种IO方式的区别"><a href="#5-几种IO方式的区别" class="headerlink" title="5.几种IO方式的区别?"></a>5.几种IO方式的区别?</h3><p><code>BUFFERED_IO</code> <code>DIRECT_IO</code> <code>OTHER_IO</code><br><code>BUFFERED_IO</code>  直接从用户空间拷贝到内核空间<br><code>DIRECT_IO</code>    使用mdl+锁的方式完成用户空间向内核空间的映射<br><code>其他方式读写</code> 当用户空间上下文一定时，可以直接读写用户空间，也就是非异步IO的典型</p>
<h3 id="6-WDM驱动"><a href="#6-WDM驱动" class="headerlink" title="6.WDM驱动?"></a>6.WDM驱动?</h3><p>WDM中通常分为,物理设备对象和功能设备对象，二者为附加被附加关系。<br>总线驱动会自动创建物理设备对象，但此设备对象并不能被直接操作，需要在其上附加功能设备对象。</p>
<h3 id="7-内核内存"><a href="#7-内核内存" class="headerlink" title="7.内核内存?"></a>7.内核内存?</h3><p>由于整个内核均位于同一片内存空间，故不宜开辟过大的空间，另外需要尽可能的避免递归调用带来的栈开销。<br><code>#pragma alloc_text(INIT, DriverEntry)</code><br><code>#pragma alloc_text(PAGE, SfFastIoRead)</code><br>等代码用于解决内存吃紧的情况<br>依据实际代码分为 <code>INIT</code> <code>PAGE</code></p>
<p>指定函数加载到非分页内存中<br><code>#pragma LOCKEDCODE</code></p>
<p>分配内存常用方法 – 加入 “tag” 可以便于调试不加tag的版本会使用默认tag<br><code>ExAllocPoolWithTag</code><br><code>ExFreePoolWithTag</code></p>
<p>池化 - <code>Lookaside</code> 防止内存碎片，适合频繁分配且粒度固定的场景</p>
<ul>
<li><p>初始化一个 list, 指定分配器、释放器, 初始化相关锁<br><code>ExInitializeNPagedLookasideList</code><br><code>ExInitializePagedLookasideList</code></p>
</li>
<li><p>从list首部弹出元素，若为空，则使用分配器分配一块内存<br><code>ExAllocateFromPagedLookasideList</code><br><code>ExAllocateFromNPagedLookasideList</code></p>
</li>
<li><p>将一块内存挂载到指定 list，若达到 list最大深度则不挂载直接释放<br><code>ExFreeToPagedLookasideList</code><br><code>ExFreeToNPagedLookasideList</code></p>
</li>
<li><p>使用 <code>ExAllocateFromPagedLookasideList</code>&#x2F;<code>ExAllocateFromNPagedLookasideList</code> 迭代list，并调用指定释放器<br><code>ExDeleteNPagedLookasideList</code></p>
</li>
<li><p>内存可用性检测 – 不推荐使用<br><code>ProbeForRead</code><br><code>ProbeForWrite</code></p>
</li>
</ul>
<h3 id="8-链表"><a href="#8-链表" class="headerlink" title="8.链表"></a>8.链表</h3><p>驱动中通常使用非侵入式的 双向链表，通常需要将 LIST_ENTRY 放入 Node 的首部，便于遍历<br><code>IsListEmpty(&amp;head)</code><br><code>InsertHeadList(&amp;head,&amp;node-&gt;ListEntry)</code><br><code>InsertTailList(&amp;head,&amp;node-&gt;ListEntry)</code><br><code>newhead = RemoveHeadList(&amp;head)</code></p>
<p><code>CONTAINING_RECORD</code> 用于得到结构体地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) ((type FAR *)( \</span></span><br><span class="line"><span class="meta">                                          (PCHAR)(address) - \</span></span><br><span class="line"><span class="meta">                                          (PCHAR)(&amp;((type *)0)-&gt;field)))</span></span><br><span class="line"></span><br><span class="line">FIELD_OFFSET 计算成员偏移</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELD_OFFSET(type, field)    ((LONG)&amp;(((type *)0)-&gt;field))</span></span><br></pre></td></tr></table></figure>

<h3 id="9-运行时"><a href="#9-运行时" class="headerlink" title="9.运行时"></a>9.运行时</h3><p>大多数运行时函数可以直接使用，例如<br><code>memcpy</code> <code>memcmp</code> <code>memset</code> 等<br>也可以使用相应的 Rtl版本</p>
<h3 id="10-IRP"><a href="#10-IRP" class="headerlink" title="10.IRP"></a>10.IRP</h3><p>当上层应用与驱动程序通信时，会由系统做语义翻译，转为IRP结构，类似调试系统中的包装。</p>
<p>对于一般的IRP请求，可以选择跳过或者完成。<br><code>IoSkipCurrentIrpStackLocation</code>——–&#x2F;&#x2F; 宏<br><code>IoCopyCurrentIrpStackLocationToNext</code>–&#x2F;&#x2F; 主要涉及完成例程，下层堆栈执行完成例程后，会将IRP的控制权交付给本层堆栈<br><code>IoSetCompletionRoutine</code>—————&#x2F;&#x2F; 在设置完成例程后，需要通过 <code>KeWaitForSingleObject</code> 自行处理<br>—————————————–&#x2F;&#x2F;<code>STATUS_PENDING</code> &#x2F; 在完成例程中通过 <code>KeSetEvent</code> 设置事件<br>—————————————–&#x2F;&#x2F; 同时返回 <code>STATUS_MORE_PROCESSING_REQUIRED</code>，会暂停向上回卷<br>—————————————–&#x2F;&#x2F; 或者在完成例程中通过 <code>IoMarkIrpPending</code> 传播挂起状态<br>—————————————–&#x2F;&#x2F; 二者区别在于是否完成IRP请求，由于调用 <code>IoCallDriver</code> 后<br>—————————————–&#x2F;&#x2F; (异步操作时，立即返回 <code>STATUS_PENDING</code>) 失去了对IRP的控制<br>—————————————–&#x2F;&#x2F; 需要通过事件的方式重获控制然后完成IRP<br>—————————————–&#x2F;&#x2F;<br>—————————————–&#x2F;&#x2F; 另外可以在完成例程中通过 <code>IoCallDriver</code><br>—————————————–&#x2F;&#x2F; 继续转发，并返回 <code>STATUS_MORE_PROCESSING_REQUIRED</code><br>—————————————–&#x2F;&#x2F; 详细参考 《驱动开发详解》 第21章</p>
<p><code>IoCompleteRequest</code>&#x2F;&#x2F; 函数</p>
<p><code>IO_STACK_LOCATION</code> &#x2F;&#x2F; io堆栈</p>
<p><code>IoMarkIrpPending</code> &#x2F;&#x2F; 挂起IRP<br><code>IoCancelIrp</code> &#x2F;&#x2F; 取消IRP</p>
<p><code>IoSetCancelRoutine</code> &#x2F;&#x2F; 设置取消例程 -&gt; 需要注意在回调中调用 <code>IoReleaseCancleSpinLock(Irp-&gt;CancelIrql)</code>,取消自旋锁是全局自旋锁，所有驱动共用，只需要调用一次。</p>
<p><code>IoAllocateIrp</code> &#x2F;&#x2F; 创建IRP</p>
<h3 id="11-IRQL与锁"><a href="#11-IRQL与锁" class="headerlink" title="11.IRQL与锁"></a>11.IRQL与锁</h3><p>IRQL 软件使用了 0-2 3个级别，剩下的为硬件中断等级<br>由于中断例程也运行于 <code>DISPATCH_LEVEL</code>,故IRQL 为<code>DISPATCH_LEVEL</code>时执行的代码不能位于分页内存，且内部不能调用可能触发异常的代码。</p>
<p>spin Lock<br><code>KeAcquiresSpinLock</code>             —–&gt; <code>KxWaitForSpinLockAndAcquire</code> (其内部就是通过nop自旋)&#x2F;<code>stdCall   _KeRaiseIrql, &lt;DISPATCH_LEVEL, esp&gt;</code> 提高运行级别<br><code>KeAcquireSpinLockAtDpcLevel</code>    —–&gt; 少了提升运行级别这一步</p>
<p><code>KfReleaseSpinLock</code><br><code>KeReleaseSpinLockFromDpcLevel</code></p>
<p>需要注意，<code>DISPATCH_LEVEL</code>并不意味着线程安全，在多核情况下依旧有用锁的必要。<br>另外需要注意，自旋锁是一种实时性较高但效率偏低的锁。</p>
<p>快速互斥锁不可重入<br>另外部分同步对象可以在应用层和驱动层中交互</p>
<p>另外可以使用 <code>ExInterLocked</code> 系列函数内部通过自旋锁实现需要提供自旋锁，同时不能操作分页内存<br><code>InterLocked</code> 系列不通过自旋锁，可以操作分页内存。</p>
<h3 id="12-异步操作"><a href="#12-异步操作" class="headerlink" title="12.异步操作"></a>12.异步操作</h3><p>类似网络编程中的异步IO</p>
<h3 id="13-StartIO"><a href="#13-StartIO" class="headerlink" title="13.StartIO"></a>13.StartIO</h3><p>实现IRP串行<br><code>StartIO</code> 例程位于 <code>DISPATCH_LEVEL</code> 级别，函数定义需要加上 <code>#pragma LOCKEDCODE</code> 保证其运行于非分页内存</p>
<h3 id="14-DPC-与-APC"><a href="#14-DPC-与-APC" class="headerlink" title="14.DPC 与 APC"></a>14.DPC 与 APC</h3><p>延迟&#x2F;异步过程调用，运行在 <code>DISPATCH_LEVEL/APC_LEVEL</code> 级别，差异在于一个是全局的 一个是针对线程的</p>
<p><code>KeInitializeDpc</code><br><code>KeInitializeApc</code></p>
<p><code>KeInsertQueueApc</code><br><code>KeInsertQueueDpc</code></p>
<h3 id="15-时间"><a href="#15-时间" class="headerlink" title="15.时间"></a>15.时间</h3><p>定时器<br><code>IoInitializeTimer</code> IO定时器<br><code>KeInitializeTimer</code> DPC定时器<br>二者的回调例程均运行于 <code>DISPATCH_LEVEL</code></p>
<p>等待<br><code>KeWaitForSingleObject</code><br><code>KeDelayExecutionThread</code><br><code>KeStallExecutionProcessor</code> – 忙等待，类似自旋锁</p>
<p>获取时间<br><code>KeQuerySystemTime</code></p>
<h3 id="16-对象"><a href="#16-对象" class="headerlink" title="16.对象"></a>16.对象</h3><p><code>ObReferenceObjectByName</code> &#x2F;&#x2F; 获取命名对象指针，会增加引用计数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对常见常用的概念，函数进行汇总说明。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《windows驱动开发详解》 张帆</p>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt文件系统(1)--sfilter</title>
    <url>/2020/03/10/nt_driver_1/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大抵了解了一下，最近驱动开发的招聘岗位依旧是对于文件系统过滤驱动和网络过滤驱动的需求。<br>一个主要是做文件透明加密，一个主要是做流量劫持。<br>关于这个驱动，文件过滤驱动稍微较网络过滤复杂一丢丢。<br>文件系统上面存在热插拔的U盘等介质，实际写法上和网络过滤驱动相接近。<br>本文主要参考解读《Windows 文件系统过滤驱动开发教程（第二版）》一文，<br>是对过滤驱动开发方面的总结性内容，也可以用作入门参考。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="驱动程序的基础开始"><a href="#驱动程序的基础开始" class="headerlink" title="驱动程序的基础开始"></a>驱动程序的基础开始</h3><p><code>DriverEntry</code> 相当于 <code>dllmain</code>，是一个驱动的入口，在驱动加载完成后由系统调用。<br>但是略有不同的是驱动程序除了入口之外还有一个独立的出口，在驱动被卸载的时候被调用，其位于驱动对象结构中，是一个函数指针。<br>至于为何要分开，我猜测是由于有些程序并不需要卸载处理，那么在 <code>DriverEntry</code> 在被调用完后，这个函数可以从内存中移除，节约一点内存。</p>
<p>驱动在加载完成后，会由系统构造一个驱动对象传入 DriverEntry，它与驱动是一一对应关系。</p>
<blockquote>
<p>DriverObject 重要之处，在于它拥有一组函数指针，称为 dispatch functions.</p>
</blockquote>
<p>通常在编写过滤设备驱动时，需要做两件事。</p>
<ul>
<li>往目标设备的设备栈附加自己的设备对象，让自己的设备对象位于目标设备上层，用于接收处理IRP。</li>
<li>当设备收到IRP后，就会交由其对应的驱动对象，而后调用驱动对象关联的派遣函数(dispatch functions)进行处理，所以需要编写对应的派遣函数。</li>
</ul>
<p>一个驱动对象可以包含多个设备对象，派遣函数的第一个参数会指明是来自于哪个设备对象，在此做相应的处理即可。</p>
<p>创建设备对象通常使用 <code>IoCreateDevice</code> 函数，而附加设备对象到目标设备对象的设备栈通常使用  <code>IoAttachDevice</code> 函数。<br>在创建设备对象时，一般会将相关的信息存放于设备对象的扩展域即DEVICE_EXTENSION中，在附加完成后或者说准备工作完成后，需要通过 newDeviceObject-&gt;Flags &amp;&#x3D; ~DO_DEVICE_INITIALIZING 清理掉初始化标志，以表示设备可以正常工作。</p>
<p>在文件系统中，通常需要关注的是卷设备对象的过滤，其涉及到对于文件的相关操作。</p>
<p>宏 <code>UNREFERENCED_PARAMETER</code> 用于消除未使用的参数警告。</p>
<h3 id="派遣函数的注册"><a href="#派遣函数的注册" class="headerlink" title="派遣函数的注册"></a>派遣函数的注册</h3><p>通常注册派遣函数的写法如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先全部初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">  DriverObject-&gt;MajorFunction[i] = SfPassThrough;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后特化处理</span></span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = SfCreate;</span><br></pre></td></tr></table></figure>

<p>其中 <code>PassThrough</code> 也有较为通用的写法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">SfPassThrough</span> <span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过当前设备栈，并移交给下层设备。</span></span><br><span class="line">  <span class="comment">// 如果是非过滤驱动，应该完成掉这个IRP请求，并指定错误码及相关信息</span></span><br><span class="line">  IoSkipCurrentIrpStackLocation( Irp );</span><br><span class="line">  <span class="keyword">return</span> IoCallDriver( ((PSFILTER_DEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension)-&gt;AttachedToDeviceObject, Irp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastIo"><a href="#FastIo" class="headerlink" title="FastIo"></a>FastIo</h3><blockquote>
<p>FastIo 是 Cache Manager 调用所引发的一种没有 irp 的请求。</p>
</blockquote>
<p><code>FastIo</code>的结构指针位于<code>driver-&gt;FastIoDispatch</code>，需要自行分配一个 <code>FAST_IO_DISPATCH </code>并填充。</p>
<p>在文件系统过滤驱动中，<code>FastIo</code>的过滤与 <code>IRP</code> 过滤同等重要，二者均可能被调用。</p>
<blockquote>
<p>在开发的初期学习阶段，你<strong>可以简单的设置所有的 fastio 例程返回 FALSE 并不做任何事。这样这些请求都会通过 IRP 重新发送被你的普通分发函数捕获</strong>。有一定的效率损失，但是并不是很大。</p>
</blockquote>
<blockquote>
<p>3.5 附：陆麟关于 fastio 的简述<br>NT 下 FASTIO 是一套 IO MANAGER 与 DEVICE DRIVER 沟通的另外一套 API. 在进行基于 IRP 为基础的接 口调用前, IO MANAGER 会尝试使用 FAST IO 接口来加速各种 IO 操作. FASTIO 本身的文档并不多见, 本篇就是要 介绍一下 FASTIO 接口.</p>
</blockquote>
<blockquote>
<ul>
<li>FastIoCheckIfPossible, 此调用并不是 IO MANAGER 直接调用. 而是被 FsRtlXXX 系列函数调用. 用于确认读写 操作是否可以用 FASTIO 接口进行.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoRead&#x2F;FastIoWrite, 很明显, 是读写处理的调用.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoQueryBasicInfo&#x2F;FastIoQueryStandardInfo, 用于获取各种文件信息. 例如创建,修改日期等.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoLock&#x2F;FastIoUnlockSingle&#x2F;FastIoUnlockAll&#x2F;FastIoUnlockAllByKey,用于对文件的锁定操作. 在 NT 中.有 2中锁定需要存在.1.排他性锁. 2.共享锁. 排他性锁在写操作前获取,不准其他进程获得写操作权限, 而共享锁 则代表需要读文件某区间. 禁止有写动作出现. 在同一地址上, 如果有多个共享锁请求, 那是被允许的.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoDeviceControl 用于提供 NtDeviceIoControlFile 的支持.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>AcquireFileForNtCreateSection&#x2F;ReleaseFileForNtCreateSection 是 NTFS 在映射文件内容到内存页面 前进行的操作.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoDetachDevice, 当 REMOVABLE 介质被拿走后, FILE SYSTEM 的 DEVICE 对象会在任意的时刻被销 毁. 只有正确处理这个调用才能把上层 DEVICE 和将要销毁的 DEVICE 脱钩. 如果不解决这个函数, 系统会当.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoQueryNetworkOpenInfo, 当 CIFS 也就是网上邻居,更准确的说是网络重定向驱动尝试获取文件信息, 会使用这个调用. 该调用是因为各种历史原因而产生. 当时设计 CIFS 时为避免多次在网上传输文件信息请求, 在 NT4 时 传输协议增加了一个 FileNetworkOpenInformation 的网络文件请求. 而 FSD 则增加了这个接口. 用于在一次操作 中获得所有的文件信息. 客户段发送 FileNetworkOpenInformation, 服务器端的 FSD 用本接口完成信息填写.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoAcquireForModWrite, Modified Page Writer 会调用这个接口来获取文件锁. 如果实现这个接口. 则 能使得文件锁定范围减小到调用指定的范围. 不实现此接口, 整个文件被锁.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoPrepareMdlWrite, FSD 提供 MDL. 以后向此 MDL 写入数据就代表向文件写入数据. 调用参数中有 FILE_BOJECT 描述要写的目标文件.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoMdlWriteComplete, 写操作完成. FSD 回收 MDL.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoReadCompressed, 当此调用被调用时, 读到的数据是压缩后的.应该兼容于标准的 NT 提供的压缩库. 因 为调用者负责解压缩.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoWriteCompressed,当此调用被调用时, 可以将数据是压缩后存储.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoMdlReadCompressed&#x2F;FastIoMdlReadCompleteCompressed, MDL 版本的压缩读. 当后一个接 口被调用时,MDL 必须被释放.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoMdlWriteCompressed&#x2F;FastIoMdlWriteCompleteCompressed, MDL 版本的压缩写.当后一个接 口被调用时,MDL 必须被释放.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoQueryOpen, 这不是打开文件的操作. 但是却提供了一个 IRP_MJ_CREATE 的 IRP. 我在以前版本的 SECUSTAR 的软件中错误地实现了功能. 这个操作是打开文件&#x2F;获取文件基本信息&#x2F;关闭文件的一个操作.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoReleaseForModWrite,释放 FastIoAcquireForModWrite 调用所占有的 LOCK.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FastIoAcquireForCcFlush&#x2F;FastIoReleaseForCcFlush FsRtl 会调用此接口,在 LAZY WRITE 线程将要把修改后的文件数据写入前调用.获取文件锁.</li>
</ul>
</blockquote>
<p>由于上面这些属于比较重要的内容，所以直接摘录过来了。</p>
<h2 id="卷的动态挂载"><a href="#卷的动态挂载" class="headerlink" title="卷的动态挂载"></a>卷的动态挂载</h2><blockquote>
<p>任何来自应用的请求，终被 windowsIO 管理器翻译成 irp 的，总是发送给设备栈的顶端那个设备。</p>
</blockquote>
<p>关于这个内容在前面已经说过了。</p>
<p>当一个U盘被插入时，系统会动态的生成(挂载)一个卷(Volume)，<br>对于文件系统过滤驱动来说，当然希望能动态的识别并往这个新建的设备对象上层加入过滤设备对象。<br>这个时候就需要用到名为 <code>IoRegisterFsRegistrationChange</code> 的函数。</p>
<p><code>IoRegisterFsRegistrationChange</code>本身并不能识别卷的创建(挂载)，它的功能是动态识别文件系统是否被激活，通过它就可以往激活的文件系统的控制设备对象附加一个过滤设备对象，进而得到发往这个文件系统的控制设备对象的IRP。</p>
<p>一个卷在被挂载时，会产生一个发往文件系统的控制设备对象的IRP，其 Major Function Code 为 IRP_MJ_FILE_SYSTEM_CONTROL，Minor Function Code 为 IRP_MN_MOUNT。</p>
<p>简单的说，就是两个步骤。</p>
<ol>
<li>IoRegisterFsRegistrationChange 注册一个回调，监视文件对象的激活和卸载，回调内完成 附加&#x2F;取消附加 文件系统控制设备对象</li>
<li>为 MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] 指定派遣函数，内部对 MinorFunction 为 IRP_MN_MOUNT 的进行 附加处理。</li>
</ol>
<p>在 <code>2000</code>以后的系统中，<code>IoRegisterFsRegistrationChange</code> 会重新枚举已经激活的文件系统，类似于调试子系统会重新将已经执行过的内容发往调试器，但是其不会重新发送卷挂载的 IRP，故需要自行枚举该文件系统下的卷设备并附加。</p>
<p>按照 sfilter 的逻辑是不会重发卷挂载的 IRP，具体会不会发我不知道，只是多附加一次也不会出错，这是因为后面附加时可以统一枚举设备栈判断设备对象的扩展域是否为NULL来识别该设备栈是否已经附加。</p>
<p>另外文件系统在激活时，并不是绑定所有设备，只需要绑定感兴趣的设备对象，可以通过 <code>DeviceObject-&gt;DeviceType</code> 进行过滤，以及通过驱动对象名过滤掉文件系统识别器(一个占坑的驱动)，一般情况下是在<code>\FileSystem\Fs_Rec</code>下面。</p>
<p>由于 <code>DISMOUNT</code> 很难被捕获，在 <code>sfilter </code> 中并未进行相关的处理，会出现影响不大的泄露。</p>
<p><code>IRP_MN_LOAD_FILE_SYSTEM</code> 是在文件系统识别器决定加载真正的文件系统时产生的请求，其中需要处理被误绑定的 文件系统识别器。由于 识别器路径不是必须为 <code>\FileSystem\Fs_Rec</code> 的缘故，所以可能会发生误绑定现象。</p>
<h2 id="卷设备的附加"><a href="#卷设备的附加" class="headerlink" title="卷设备的附加"></a>卷设备的附加</h2><p>前面已经提及，文件系统过滤驱动中，真正需要处理是卷设备的行为过滤。<br><code>IRP_MN_MOUNT_VOLUME</code> 可以感知到将要被创建的卷设备，当挂载请求到来时，能得到一个 VPB 结构，它将磁盘设备对象和卷设备对象关联起来，但是卷设备实际是在请求完成之后才会被真正创建，而请求完成后下层的文件系统驱动可能已经修改了 VPB 的值，所以需要提前将其保存起来。在完成例程中去获取真正的卷设备。</p>
<p>VPB-&gt;RealDevice是    磁盘驱动创建的物理设备对象<br>VPB-&gt;RealDevice      中又存在指向 VPB的指针，但是并不清楚 VPB 是否等于 VPB-&gt;RealDevice-&gt;VPB<br>VPB-&gt;DeviceObject是  文件系统创建的卷设备对象</p>
<p>相当于先保存 VPB-&gt;RealDevice 磁盘设备对象，在请求完成后再通过 RealDevice-&gt;VPB-&gt;DeviceObject 获取卷设备对象。</p>
<p>一种更通用的做法是将一个事件作为完成函数的上下文进行投递，再在其完成函数中激活，这样就能在其他地方感知到完成事件了，另外使用该方法也能绕开 IRQL级别的限制，另外在 2000上有个讨厌的死锁问题，可以通过 <code>DelayedWorkQueue</code> 委托，这里不细看了，基本上不会再为 2000 写驱动了。</p>
<p><strong>值得注意的是</strong>：根据官方文档</p>
<blockquote>
<p>IoCompletion routine is called at IRQL &lt;&#x3D; DISPATCH_LEVEL</p>
</blockquote>
<p>完成例程可能运行于 DISPATCH_LEVEL，故 上下文(事件) 必须分配于 nonpaged memory，sfilter是直接分配于栈上，就我个人理解，内核栈是不会被交换的(否则运行这么多年早就错误百出了)。</p>
<p>另外在附加前需要检查目标设备栈是否已经附加，sfilter中是遍历了整个设备栈，当然也可以只判断顶部那个(可能会遗漏)，判断其扩展域是否为 NULL就行了，可以利用宏 ARGUMENT_PRESENT。当然在检查附加及附加这段是需要同步的，在取消时同样。</p>
<p>本文略过卷影部分。</p>
<blockquote>
<p>卷影拷贝服务(Volume Shadow Copy Service，VSS)是一种备份和恢复的技术。它是一种基于时间点来备份文件拷贝的技术，可以过滤也可以不过滤。</p>
</blockquote>
<h2 id="读写过滤"><a href="#读写过滤" class="headerlink" title="读写过滤"></a>读写过滤</h2><blockquote>
<p>处理 IRP_MJ_READ 和 IRP_MJ_WRITE,能捕获文件的读写操作.</p>
</blockquote>
<p>在 sfilter 中并未对这些进行处理而集中 FastIO.</p>
<blockquote>
<p>LARGE_INTEGER offset; Offset.QuadPart &#x3D; irpsp-&gt;Parameters.Read.ByteOffset.QuadPart;<br>而读取文件的长度则是:<br>ULONG length; length &#x3D; irpsp-&gt;Parameters.Read.Length;<br>写的偏移量和长度则为:<br>Offset.QuadPart &#x3D; irpsp-&gt;Parameters.Write.ByteOffset.QuadPart;<br>length &#x3D; irpsp-&gt;Parameters.Write.Length;</p>
</blockquote>
<p>由于捕获这个请求的时候，请求还未完成，故无法获取到即将被读取的数据。</p>
<blockquote>
<p><strong>完成 Irp 的时候忽略还是拷贝当前 IO_STACK_LOCATION,返回什么 STATUS,以及完成函数中如何结束 Irp,是 不那么容易搞清楚的一件事情.我想做个总结如下:</strong></p>
</blockquote>
<blockquote>
<p>1.如果对 irp 完成之后的事情无兴趣,直接忽略当前 IO_STACK_LOCATION,(对我们的程序来说,调用 IoSkipCurrentIrpStackLocation),然后向下传递请求,返回 IoCallDriver 所返回的状态.</p>
</blockquote>
<blockquote>
<p>2.不但对 irp 完成之后的事情无兴趣,而且我不打算继续传递,打算立刻返回成功或失败.那么我不用忽略或者拷贝当前 IO_STACK_LOCATION,填写参数后调用 IoCompleteRequest,并返回我想返回的结果.</p>
</blockquote>
<blockquote>
<p>3.如果对 irp 完成之后的事情有兴趣, 并打算在完成函数中处理, 应该首先拷贝当前 IO_STACK_LOCATION(IoCopyCurrentIrpStackLocationToNext), 然后指定完成函数, 并返回 IoCallDriver()所返回的 status.完成函数中,不需要调用 IoCompleteRequest!直接返回 Irp 的当前状态即可.</p>
</blockquote>
<blockquote>
<p>4.同 3 的情况,有时候,会把任务塞入系统工作者线程或者希望在另外的线程中去完成 Irp,那么完成函数中应该返回 STATUS_MORE_PROCESSING_REQUIRED,此时完成 Irp 的时候应该调用 IoCompleteRequest.另一种类似 的情况是在 dispatch 函数中等待完成函数中设置事件, 那么完成函数返回 STATUS_MORE_PROCESSING_REQUIRED,dispatch 函数在等待结束后调用 IoCompleteRequest.</p>
</blockquote>
<p>关于IO的几种方式在先前的复习中已经总结了。<br>缓冲方式 直接方式 其他方式。</p>
<p>其他方式需要在同一进程上下文环境才能处理，其他两种则没有这种限制。<br>根据设备对象的IO标志可以判断其IO方式。</p>
<p>直接IO方式可通过判断 <code>Irp-&gt;MdlAddress</code> 是否NULL，并通过 <code>MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);</code> 获取缓冲区地址。</p>
<p>剩下两种只要保证进程上下文不变，可以直接从<code>Irp-&gt;UserBuffer</code>中获取缓冲区地址。</p>
<p>读请求的buffer需要在请求完成时才能提取，而写请求则不需要。</p>
<h3 id="读请求的完成"><a href="#读请求的完成" class="headerlink" title="读请求的完成"></a>读请求的完成</h3><p>略。</p>
<h2 id="文件和目录的创建，打开，关闭，删除"><a href="#文件和目录的创建，打开，关闭，删除" class="headerlink" title="文件和目录的创建，打开，关闭，删除"></a>文件和目录的创建，打开，关闭，删除</h2><p>实际上重命名操作也可以归纳到一起。</p>
<p>目录相关的处理老实说比较复杂，我就简单的说一下如何 过滤删除和重命名。</p>
<p><code>FileDispositionInformation == Iopb-&gt;Parameters.SetFile.FileInformationClass</code><br><code>|| FileRenameInformation == Iopb-&gt;Parameters.SetFile.FileInformationClass</code><br>通过上面两条就能过滤出 删除和重命名操作了。<br>接着通过<br><code>IoGetCurrentIrpStackLocation(Irp)-&gt;ileObject-&gt;FileName</code><br>就能获得文件名，其类型为 UNICODE_STRING。<br>至于如何处理，就依需求了。</p>
<h2 id="派遣函数重入问题"><a href="#派遣函数重入问题" class="headerlink" title="派遣函数重入问题"></a>派遣函数重入问题</h2><p>通常要避免重入造成的死循环。</p>
<p>驱动开发中 由于内核栈的短缺，本身也应该避免递归造成的重入。<br>另一种是函数内部调用的某个函数会触发对应的IRP请求，又会回到该函数，而导致死循环。</p>
<p>这实际上对程序逻辑理解上的疏忽造成的，通常并不会出现，如果有必要出现时，需要进行过滤。<br>同样也可以通过创建任务线程来处理，具体可以看本文参考文章的相关部分。</p>
<p>##总结<br>本文主要结合《Windows 文件系统过滤驱动开发教程（第二版）》一文，介绍了<code>sfilter</code> 中的核心部分，并加入了一些个人见解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://localhost/usr/uploads/2020/01/4020919378.pdf">Windows 文件系统过滤驱动开发教程（第二版）</a></li>
</ul>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt文件系统(2)--minifilter</title>
    <url>/2020/03/10/nt_driver_2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面总结了 sfilter 相关的内容，接下来就该轮到minifilter了。</p>
<h2 id="minifilter基础"><a href="#minifilter基础" class="headerlink" title="minifilter基础"></a>minifilter基础</h2><p>minifilter可以简单理解为微软自己开发了一个相当于sfilter的驱动，并提供了相关接口供其他驱动使用。</p>
<p>由于sfilter本身的复杂性极高，一个是在不同版本系统下的兼容性问题，一个是与核心需要的业务逻辑相比，无关的代码太多，故使用 minifilter是一个很好的选择，但是由于 minifilter本身也是基于传统的设备过滤驱动实现的，故在系统中存在其他 sfilter 的时候优先级会比别人低。</p>
<h2 id="minifilter框架"><a href="#minifilter框架" class="headerlink" title="minifilter框架"></a>minifilter框架</h2><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><blockquote>
<p>微型文件过滤驱动程序的DriverEntry例程必须按顺序执行以下步骤：</p>
<ol>
<li>初始化所需的全局变量</li>
<li>通过调用FltRegisterFilter注册一个过滤器。</li>
<li>通过调用FltStartFiltering启动过滤器。</li>
<li>返回相应的 NTSTATUS 值。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>在卸载驱动时调用 FltUnregisterFilter 卸载过滤器</li>
</ol>
</blockquote>
<h3 id="相关函数及结构"><a href="#相关函数及结构" class="headerlink" title="相关函数及结构"></a>相关函数及结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS FLTAPI <span class="title function_">FltRegisterFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">  PDRIVER_OBJECT          Driver,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> FLT_REGISTRATION *Registration,</span></span><br><span class="line"><span class="params">  PFLT_FILTER            *RetFilter</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>共有三个参数，第一个参数传入本驱动对象的指针，第二个参数是一个 FLT_REGISTRATION 结构，其中便存在注册过滤例程的地方了，第三个参数是一个返回值，其作用相当于一个句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS FLTAPI <span class="title function_">FltStartFiltering</span><span class="params">(</span></span><br><span class="line"><span class="params">  PFLT_FILTER Filter</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>一个参数，即注册时返回的句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FLT_REGISTRATION</span> &#123;</span></span><br><span class="line">  USHORT                                      Size;                 <span class="comment">// 结构大小</span></span><br><span class="line">  USHORT                                      Version;              <span class="comment">// 结构版本</span></span><br><span class="line">  FLT_REGISTRATION_FLAGS                      Flags;                <span class="comment">// 过滤器标志</span></span><br><span class="line">  <span class="type">const</span> FLT_CONTEXT_REGISTRATION              *ContextRegistration; <span class="comment">// 上下文注册</span></span><br><span class="line">  <span class="type">const</span> FLT_OPERATION_REGISTRATION            *OperationRegistration; <span class="comment">// **操作回调例程**</span></span><br><span class="line">  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;   <span class="comment">// 卸载回调例程</span></span><br><span class="line">  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;  <span class="comment">// 实例安装例程，卷实例加载时触发</span></span><br><span class="line">  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;   <span class="comment">// 手工解除绑定时触发</span></span><br><span class="line">  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;   <span class="comment">// 已经决定解绑时触发</span></span><br><span class="line">  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback; <span class="comment">// 实例解绑完成时触发</span></span><br><span class="line">  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;     <span class="comment">// 生成文件名回调</span></span><br><span class="line">  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;</span><br><span class="line">  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;</span><br><span class="line">  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;</span><br><span class="line">  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;</span><br><span class="line">  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;</span><br><span class="line">&#125; FLT_REGISTRATION, *PFLT_REGISTRATION;</span><br></pre></td></tr></table></figure>
<p>具体可以参考 MSDN 相关</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_registration">FLT_REGISTRATION结构</a></li>
</ul>
<p>其中最为重要的便是 OperationRegistration 成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FLT_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">  UCHAR                            MajorFunction;</span><br><span class="line">  FLT_OPERATION_REGISTRATION_FLAGS Flags;</span><br><span class="line">  PFLT_PRE_OPERATION_CALLBACK      PreOperation;</span><br><span class="line">  PFLT_POST_OPERATION_CALLBACK     PostOperation;</span><br><span class="line">  PVOID                            Reserved1;</span><br><span class="line">&#125; FLT_OPERATION_REGISTRATION, *PFLT_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>
<p>MajorFunction 主功能号，Flags 指定过滤哪种类型的请求，可以为0， Pre IRP完成前执行的回调例程，Post IRP完成后执行的完成例程，Reserved1 保留供系统使用。</p>
<p>例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FLT_OPERATION_REGISTRATION</span><br><span class="line">fileMonitorCallbacks[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        IRP_MJ_CREATE,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        PreNtCreateFile,</span><br><span class="line">        PostNtCreateFile</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        IRP_MJ_WRITE,</span><br><span class="line">        FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO,<span class="comment">// 忽略分页读/写 请求</span></span><br><span class="line">        PreNtWriteFile,</span><br><span class="line">        PostNtWriteFile</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        IRP_MJ_OPERATION_END<span class="comment">//这个是必须要加的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>PFLT_PRE_OPERATION_CALLBACK</code> <code>FLT_POSTOP_CALLBACK_STATUS</code> 原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;</span><br><span class="line"></span><br><span class="line">FLT_PREOP_CALLBACK_STATUS <span class="title function_">PfltPreOperationCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">  PFLT_CALLBACK_DATA Data,</span></span><br><span class="line"><span class="params">  PCFLT_RELATED_OBJECTS FltObjects,</span></span><br><span class="line"><span class="params">  PVOID *CompletionContext</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;</span><br><span class="line"></span><br><span class="line">FLT_POSTOP_CALLBACK_STATUS <span class="title function_">PfltPostOperationCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">  PFLT_CALLBACK_DATA Data,</span></span><br><span class="line"><span class="params">  PCFLT_RELATED_OBJECTS FltObjects,</span></span><br><span class="line"><span class="params">  PVOID CompletionContext,</span></span><br><span class="line"><span class="params">  FLT_POST_OPERATION_FLAGS Flags</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>其参数 <code>FLT_CALLBACK_DATA</code> 相当于对原来的 <code>IRP</code> 进行了包装，避免直接与<code>IRP</code>打交道。<br>另外可以通过其返回值轻易控制 IRP的状态，完成(FLT_PREOP_COMPLETE)，挂起(FLT_PREOP_PENDING)，传递(FLT_PREOP_SUCCESS_WITH_CALLBACK) 等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FLT_CALLBACK_DATA</span> &#123;</span></span><br><span class="line">  FLT_CALLBACK_DATA_FLAGS     Flags;</span><br><span class="line">  PETHREAD                    Thread;</span><br><span class="line">  PFLT_IO_PARAMETER_BLOCK     Iopb;</span><br><span class="line">  IO_STATUS_BLOCK             IoStatus;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">FLT_TAG_DATA_BUFFER</span> *<span class="title">TagData</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      LIST_ENTRY QueueLinks;</span><br><span class="line">      PVOID      QueueContext[<span class="number">2</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID FilterContext[<span class="number">4</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  KPROCESSOR_MODE             RequestorMode;</span><br><span class="line">&#125; FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;</span><br></pre></td></tr></table></figure>

<p>minifilter 本身也提供了一系列函数用于处理 <code>FLT_CALLBACK_DATA</code> 的相关信息。</p>
<p>例如可以通过 <code>FltGetFileNameInformation</code> 获取文件名信息，再通过 <code>FltParseFileNameInformation</code> 拆分为更加易用的格式，使用完毕之后再通过 <code>FltReleaseFileNameInformation</code> 回收相关资源。<br>又例如给文件对象绑定上下文信息等等操作。</p>
<p>通过设置 IoStatus 则可以控制请求的结果信息。<br>在 <code>FLT_IO_PARAMETER_BLOCK</code> 也存放着许多需要关注的信息，如要 得到读写的具体内容等就要从该结构入手。<br>由于篇幅限制，就不一一展开，在MSDN文档上有对其详细的描述。</p>
<h3 id="minifilter之应用层通信"><a href="#minifilter之应用层通信" class="headerlink" title="minifilter之应用层通信"></a>minifilter之应用层通信</h3><p>除了常规的设备通信方式外，minifilter内部封装了一套更为方便的通信机制。</p>
<p>主要函数如下:<br><code>FltBuildDefaultSecurityDescriptor </code> 创建默认的安全描述符<br><code>FltCreateCommunicationPort</code> 创建一个服务端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSTATUS status;</span><br><span class="line">PSECURITY_DESCRIPTOR sd;</span><br><span class="line">OBJECT_ATTRIBUTES oa;</span><br><span class="line">UNICODE_STRING uniString;</span><br><span class="line"></span><br><span class="line">status=FltBuildDefaultSecurityDescriptor(&amp;sd,FLT_PORT_ALL_ACCESS);</span><br><span class="line">RtlInitUnicodeString( &amp;uniString, MINISPY_PORT_NAME );</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化对象属性</span></span><br><span class="line">InitializeObjectAttributes( &amp;oa,</span><br><span class="line">    &amp;uniString,</span><br><span class="line">    OBJ_KERNEL_HANDLE|OBJ_CASE_INSENSITIVE,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    sd );</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核建立通信端口</span></span><br><span class="line">status = FltCreateCommunicationPort(gFilterHandle,&amp;gServerPort,&amp;oa,<span class="literal">NULL</span>,MiniConnect,MiniDisconnect,MiniMessage,<span class="number">1</span>);</span><br><span class="line">FltFreeSecurityDescriptor( sd );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 <code>gFilterHandle</code> 及注册minifilter返回的句柄，<code>MiniConnect</code> <code>MiniDisconnect</code> <code>MiniMessage</code> 为事件回调，在相应事件到达时触发。<br>相关函数<br><code>FltCloseClientPort</code> 在 <code>MiniDisconnect </code>中关闭用户端口<br><code>FltSendMessage</code> 向正在等待的用户层发送<br><code>FltCloseCommunicationPort</code> 在驱动卸载时关闭监听端口</p>
<p>##小拓展<br>Ps.刚刚在看相关博客时就发现一个他写了个<code>bug</code>，网上的代码真的不要随便用</p>
<p>实际上之前用内核管道做过测试，这种异步IO的方式本身效率不高，并不适合频繁传输，<br>对频繁传输，还是推荐使用 IO方式中的其他方式，在同一进程上下文时，直接操作进程，并通过共享事件的方式做互相通知更为高效。</p>
<p>有人肯定会说，别人都是说线程上下文，为什么你说的是进程上下文？<br>能否直接操作r3进程内存，看的是当前是进程上下文，一个进程中的多个线程的上下文都可以被直接操作，只是说判断某个线程是否属于某个进程要麻烦一丢丢，并非在某个特定的线程上下文才能访问进程空间。<br>例如调用 同步的<code>DeviceIoControl</code> 的线程会陷入内核调用派遣函数，那么派遣函数就和 <code>DeviceIoControl</code> 在同一线程上下文，也就在同一进程上下文，此时是可以直接操作进程空间的。<br>一般可以认为在异步中，其上下文是不可控的，这是由于实现异步的交付者是不可控的，你要说是某进程内部实现的协程也是可以的。这里主要指系统级的异步，极有可能会在其他进程的上下文交付。</p>
<h2 id="minifilter-动态安装卸载"><a href="#minifilter-动态安装卸载" class="headerlink" title="minifilter 动态安装卸载"></a>minifilter 动态安装卸载</h2><p>网上随便找了一篇，并未测试，按照他的说法是在注册表中创建相关子键和键值</p>
<blockquote>
<p><code>SYSTEM\\CurrentControlSet\\Services\\DriverName\\Instances</code><br><code>SYSTEM\\CurrentControlSet\\Services\\DriverName\\Instances\\DriverName Instance</code></p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/js2854/archive/2011/04/03/sysload.html">Minifilter的动态安装、加载及卸载</a></li>
</ul>
<p>话说回来，网上大多数流传已久的驱动加载方式本来就有点问题，会出现重启都卸载不干净的情况，编码不规范造成的，这块是个细节。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是官方文档和众多参考文章汇集而成，由于 minifilter 并不需要像 sfilter 那样悉知细节，故相较之要简单许多。</p>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt文件系统(3)--文件透明加密</title>
    <url>/2020/03/10/nt_driver_3/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经总结了几种常见的文件系统过滤驱动，接下来将其延申至应用领域，其中一种比较常见的便是文件透明加密系统，这是一种防止企业内部数据泄露的手段，是实现泄露数据追踪的有效方法之一。</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文件透明加密系统可以简单理解对系统中指定类型的文件进行加解密，这一过程对于用户是没有感知的，但是当用户试图将文件通过某途径泄露（拷贝等）时，其被泄露的只会是一个被加密过的文件，也就限制了文件的流通。</p>
<p>文件透明加密系统中着重需要关注的几个问题：</p>
<ul>
<li>进程的有效标识</li>
<li>加密文件的有效标识</li>
<li>双缓存问题(授权进程与非授权进程不能打开同一块缓存)</li>
<li>安全性问题</li>
</ul>
<p>本文将一一逐一说明，当然限于自身能力及参考资料过少的问题，其中部分并不能很详细的说清。</p>
<h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><h3 id="文件系统过滤基础"><a href="#文件系统过滤基础" class="headerlink" title="文件系统过滤基础"></a>文件系统过滤基础</h3><img src="/2020/03/10/nt_driver_3/image-20221010185916016.png" class="" alt="image-20221010185916016">


<p>上图展示了文件IO的基本过程。</p>
<img src="/2020/03/10/nt_driver_3/image-20221010185929977.png" class="" alt="image-20221010185929977">


<p>上图展示了文件过滤驱动在IO过程中所处的位置。</p>
<p>要实现一个文件透明加密首先需要做的就研究 <code>IRP</code> 的过滤，假设当前已经使用了微过滤框架，那么最少需要对以下几大类进行注册。</p>
<ol>
<li>IRP_OPERATION：基本的 I&#x2F;O 操作</li>
<li>IRP_GENERATED_IO：由 Minifilter 自身构造的 I&#x2F;O 请求</li>
<li>FAST_IO_OPERATION：基于系统缓存机制的快速访问 I&#x2F;O 请求，它会直接访问系统缓存内容</li>
</ol>
<h3 id="重入问题"><a href="#重入问题" class="headerlink" title="重入问题"></a>重入问题</h3><p>由于在文件透明加密系统中需要用到读写文件相关的函数，故需要解决重入问题。<br>在<code>minifilter</code> 中可以简单的通过 <code>Flt</code> 系列函数避免 IRP 重入问题。<br>至于在传统的过滤驱动中避免 IRP 重入，存在有多种方法，这里就不细说了。</p>
<h3 id="文件缓存管理器"><a href="#文件缓存管理器" class="headerlink" title="文件缓存管理器"></a>文件缓存管理器</h3><p>操作系统为了更快的响应读写，提供了对于文件数据的缓存功能。<br>当应用程序以缓存方式发送的 I&#x2F;O 请求， I&#x2F;O 管理器会以 Fast I&#x2F;O 快速方式来处理该请求， 它不会产生 IRP 数据包， 而是直接访问缓存管理器和系统中的缓存区交互， 从而导致过滤驱动实例无法截取到它。<br>在常规的文件系统过滤驱动中，fastio 是一个相对不易处理的部分，可以选择直接返回FALSE，统一使用<code>IRP</code>过滤，当然这种方式会大大降低文件的操作效率。</p>
<p>在单缓存情况下，为了实现授信进程缓存与非授信进程缓存之间的切换，需要对  IRP 的 IRP_MJ_CLOSE 或者 IRP_MJ_CLEANUP 例程进行处理，可以通过 CcFlushCache 例程清除缓存数据，但是这种做法又可能导致其它问题。</p>
<p>相对较好的办法是使用双缓存机制，即为授信与非授信进程各分配一块缓存区，缺点是会增加设计复杂度及内存开销。</p>
<h2 id="可信进程识别"><a href="#可信进程识别" class="headerlink" title="可信进程识别"></a>可信进程识别</h2><p>很多示例或说明中，要么使用md5 要么使用文件名作为可信任进程，<br>关于这点，其中各有缺点。<br>当然本来也不应该对该系统的安全性做到抛根挖底，这种对抗性的问题除非自己实现一个操作系统方可解决。<br>一般的对抗会在牢固和兼容性中间找平衡。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="加密文件标识"><a href="#加密文件标识" class="headerlink" title="加密文件标识"></a>加密文件标识</h3><p>关于加密标识存放的位置，有多种选择，有人说放文件头，有人说放文件尾，有人说拆开成独立文件，也有人放在文件流(这种只适用于NTFS)，这个见仁见智了，各有优缺。</p>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法可以采用非对称算法，也可以使用对称算法，从算法的速度上讲，对称算法比非对称算法要快上一丢丢。<br>有用 AES 的 有用 RSA的，还有用位异或表的，也有那种多重加密的。<br>总之，速度跟强度一般成正比。</p>
<h2 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h2><p>在使用文件映射读写文件时，其又是一种情况。</p>
<img src="/2020/03/10/nt_driver_3/image-20221010185958644.png" class="" alt="image-20221010185958644">


<p>能直接从缓存管理器-&gt;虚拟内存管理器中请求到数据称为:<strong>缓存读写请求</strong><br>若缓存管理器中不能直接请求得到，<br>会经由虚拟内存管理器-&gt;IO管理器向文件系统发出非缓存的分页IO请求，这种称为<strong>分页读写请求</strong></p>
<p><strong>故分页读写请求可以跟非缓存读写请求归并到一起，都是由文件系统直接向下层设备请求数据并返回</strong></p>
<h2 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h2><p>根据 <a href="https://blog.csdn.net/orbit/article/details/9907335?utm_source=blogxgwz6">《基于文件过滤驱动的透明加密那点事儿》</a>一文的说明，使用双缓存的方式属于三代以后的技术。</p>
<p>第一代中并不使用驱动实现。<br>第二代中需要不断的清理缓存，既复杂，且容易出现问题。<br>另一种便是完全忽略 fastio及缓存读写，虽然效率低下，但可以避免第二代中的技术难题。<br>第三代和第四代均使用 <code>Layerfsd</code>的双缓存实现，区别仅在于一个是传统过滤驱动，一个是新的 minifilter。</p>
<p>虽然我很想花大量篇幅谈这个，但是网上只能找到两份代码作为参考</p>
<ul>
<li>一份略残缺基于 minifilter – （X70FSD）</li>
<li>一份很乱基于 sfilter 实现 – （SfilterdoubleFcb）</li>
</ul>
<p>剩下的七七八八的论文中都将这块视作黑盒，草草几句带过。</p>
<p><code>X70FSD</code> 我只简单读了一下，基本是参考 <code>fastfat</code> 来实现，另外它并不完整，只有核心部分，剩下的部分基本可以从核心推导出来，中间还用到内核非导出函数，具体可行自行阅读，建议阅读时对着 <code>fastfat</code> 一起。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文展示文件透明加密系统的一些基础内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/xiao70/article/details/24453151">关于layerfsd的实现与思路</a></li>
<li><a href="https://blog.csdn.net/orbit/article/details/9907335?utm_source=blogxgwz6">基于文件过滤驱动的透明加密那点事儿</a></li>
<li><a href="https://github.com/xiao70/X70FSD">github: X70FSD</a></li>
</ul>
<h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><ul>
<li><a href="https://www.docin.com/p-1398489341.html">基于双缓冲过滤驱动的透明加密系统研究与实现</a></li>
<li><a href="http://www.doc88.com/p-1886400428927.html">基于Minifilter微框架的文件加解密系统的设计与实现</a></li>
</ul>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt驱动开发(4)--虚拟磁盘及磁盘过滤</title>
    <url>/2020/03/10/nt_driver_4/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<p><del>本质就是个传统型的过滤驱动。</del></p>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt网络过滤(5)--TDI过滤驱动</title>
    <url>/2020/03/10/nt_driver_5/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本篇开始，将来聊一下网络过滤驱动。</p>
<h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><p>在谈这个之前，要简单介绍一下网络分层模型。<br>常见的有 4，5，7层模型。</p>
<img src="/2020/03/10/nt_driver_5/image-20221010190226699.png" class="" alt="image-20221010190226699">



<img src="/2020/03/10/nt_driver_5/image-20221010190237106.png" class="" alt="image-20221010190237106">


<p>在4层模型中，将数据链路层和物理层合并为了网络接口层。<br>一份数据要经由网络传递时，该数据会逐层包装成相应的协议格式提供给各方使用，在到达后又会逐层解包。</p>
<p>之所以会这么做，是为了满足不同需求(有时候需要保证数据正确到达，有时不需要等等各类情况)，归根揭底的原因是网络硬件设备并不可靠，传输速度并不够快，所以需要协议来弥补这些缺陷，可以简单认为是硬件不够完美。</p>
<p>其间每一层都肩负着各自的任务，用 <code>c++</code> 的话说，它们是继承关系，下面是父类上面是子类，一顺继承下去，各自又包含各自的方法和属性。</p>
<p>具体可配合<code>RFC手册</code>，在 <code>wireshark</code> 中抓一个包来查看，本文只是为了建立这样一种概念。</p>
<h2 id="TDI在哪"><a href="#TDI在哪" class="headerlink" title="TDI在哪?"></a>TDI在哪?</h2><img src="/2020/03/10/nt_driver_5/image-20221010190255459.png" class="" alt="image-20221010190255459">


<p>本文所讲的 <code>TDI</code> 全称为 <code>Transport Driver Interface</code>，位于网络模型中的传输层，其分为3个部分，分别是 TDI客户驱动，TDI接口，以及TDI传输驱动。</p>
<p>TDI接口是在联系TDI客户驱动和TDI传输驱动时所构建的一套函数，数据及宏定义。</p>
<ul>
<li>AFD.sys，NETBT.sys 和 Http.sys都是TDI 客户驱动。</li>
<li>TCPIP.sys，NWLINK.sys和TCPIP6.sys都是TDI传输驱动。</li>
<li>TDI.sys 一般视为为 TDI 接口驱动。</li>
</ul>
<p><strong>虽然TDI客户驱动一般在TDI传输驱动上层，但也有些TDI客户驱动在网络栈中逻辑上是和TDI传输驱动在同一层甚至在TDI传输驱动下层。</strong></p>
<p>另外由于TDI层较为接近应用层，在TDI层过滤更为容易获得应用程序相关信息。</p>
<h2 id="TDI相关驱动开发"><a href="#TDI相关驱动开发" class="headerlink" title="TDI相关驱动开发"></a>TDI相关驱动开发</h2><p>在做TDI相关开发时，一般分为以下两类</p>
<ul>
<li>调用 TDI 接口，在内核模式下进行网络编程</li>
<li>针对指定传输层协议做网络流量过滤</li>
</ul>
<p>自 <code>Windows Vista</code> 起，微软为以上两大用途都提供了新的解决方案。</p>
<ul>
<li><a href="https://blogs.msdn.microsoft.com/wndp/2006/02/24/introduction-to-winsock-kernel-wsk/">WSK</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/network/windows-filtering-platform-callout-drivers2?redirectedfrom=MSDN">WFP</a></li>
</ul>
<p>本文要说明的内容便是 针对指定传输层协议做网络流量过滤 这一种使用方式。</p>
<h2 id="TCP过滤–附加设备"><a href="#TCP过滤–附加设备" class="headerlink" title="TCP过滤–附加设备"></a>TCP过滤–附加设备</h2><p>要过滤 “TCP” 协议数据，需要附加到 <code>\Device\TCP</code> 所处的设备栈。<br>其在 <code>Windows Vista</code> 之前由 “tcpip.sys” 创建，<br>而之后的版本中则由 “tdx.sys” 创建。<br><code>TDX</code>是微软提供的一种妥协方案，旨在为旧TDI驱动提供兼容。</p>
<img src="/2020/03/10/nt_driver_5/image-20221010190327813.png" class="" alt="image-20221010190327813">


<p>笔者的电脑使用的<code>win10</code>，可以看到此时该设备由 <code>tdx</code> 创建。<br><strong>当然这些都不是重点，在附加的时候并不需要这个设备由哪个驱动创建。</strong></p>
<p>既然是传统过滤驱动，要做的事情也很简单</p>
<ol>
<li>打开目标设备</li>
<li>创建过滤设备附加到目标设备的设备栈</li>
</ol>
<p><strong>具体可以参考开源项目 <code>tdifw</code>。</strong></p>
<h2 id="TCP过滤–IRP请求"><a href="#TCP过滤–IRP请求" class="headerlink" title="TCP过滤–IRP请求"></a>TCP过滤–IRP请求</h2><p>由于这类驱动中除了过滤用的设备，还有驱动本身和应用层通信的设备，所以要在派遣函数中分别处理。</p>
<p>通常比较关注的是 <code>MajorFunction</code> <code>IRP_MJ_INTERNAL_DEVICE_CONTROL</code> 的请求，<br>其 <code>MinorFunction</code> 包含</p>
<blockquote>
<p>TDI_ACCEPT<br>TDI_LISTEN<br>TDI_CONNECT<br>TDI_SEND<br>TDI_RECEIVE<br>TDI_DISCONNECT<br>…</p>
</blockquote>
<p>可以过滤诸如 连接，收发等操作。</p>
<p>在 IrpSp-&gt;Parameters 中存放着一个相关联的结构，通过该结构就能进一步提取信息，以此决定接下来的操作(例如禁止目标访问网络等),<br>可以挂起这个请求，也可以完成掉，又或者是继续下发，这点根据实际需求判断即可，在写法上，和其他传统过滤驱动并无太大的区别。</p>
<p>具体的操作说明可到<code>MSDN</code>中查看。</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/network/ff565106%28v=vs.85%29">IRP_MJ_INTERNAL_DEVICE_CONTROL</a></li>
</ul>
<p>最后值得注意的是<br><strong>过滤驱动最好不要卸载，不然很容易BSOD，这是由于无法判断(或者很难判断)是否还存在某线程在执行当前驱动的派遣函数</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文概括TDI过滤驱动的基础实现及相关知识。</p>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt网络过滤(6)--WFP</title>
    <url>/2020/03/10/nt_driver_6/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为现在主流的过滤方案 <code>WFP</code> 已经占据一定市场地位，<br>毕竟到本文行文这个时间点上，还在使用xp系统的已经屈指可数了。</p>
<p>本文将来聊一聊<code>WFP</code> 有关的一些内容。</p>
<h2 id="WFP"><a href="#WFP" class="headerlink" title="WFP"></a>WFP</h2><h3 id="WFP是什么"><a href="#WFP是什么" class="headerlink" title="WFP是什么?"></a>WFP是什么?</h3><blockquote>
<p>By providing a simpler development platform, WFP is designed to replace previous packet filtering technologies such as Transport Driver Interface (TDI) filters, Network Driver Interface Specification (NDIS) filters, and Winsock Layered Service Providers (LSP).Starting in Windows Server 2008 and Windows Vista, the firewall hook and the filter hook drivers are not available; applications that were using these drivers should use WFP instead.</p>
</blockquote>
<p>WFP 设计目的是为了替代以前的数据包过滤技术，例如 TDI 过滤， NDIS 过滤 以及 LSP。自 <code> Windows Server 2008 &amp;&amp; Windows Vista</code> 起，以前的过滤方式不再有效，这些程序均需要改用 <code>WFP</code>实现。</p>
<img src="/2020/03/10/nt_driver_6/image-20221010190529942.png" class="" alt="image-20221010190529942">



<p>首先过滤器引擎包含用户模式组件及内核模式组件两大部分，它们将共同完成数据过滤工作。<br>然而无论使用用户模式过滤引擎还是内核模式过滤引擎，最终都是与内核模式过滤引擎交互。</p>
<p>再看这两个组件中又包含有多个过滤层，通常称为分层，这多个过滤层又被分别对应着具体的网络协议栈。<br>又根据过滤层所属的组件，分为了用户模式过滤层及内核模式过滤层。</p>
<p>用户模式组件是针对 <code>RPC</code> 和 <code>IPsec</code> 的过滤，其中包含有10个用户模式过滤层。<br>内核模式组件属于 <code>WFP</code>的核心部分，主要在 <code>TPC/IP</code>协议栈及传输层进行过滤，包含大约50个内核模式过滤层。</p>
<p>接着看 <code>Shim</code>，通常翻译为垫片，其被以内核模块的形式插入到网络协议栈中，负责网络协议栈和过滤引擎交互，关于垫片，在实际开发并不需要关注。</p>
<h3 id="过滤引擎概览"><a href="#过滤引擎概览" class="headerlink" title="过滤引擎概览"></a>过滤引擎概览</h3><img src="/2020/03/10/nt_driver_6/image-20221010190545065.png" class="" alt="image-20221010190545065">



<p>在概览图和上面的框架图中，都能看到一个名为 <code>Callout</code> 的模块，官网上使用的机翻，翻译为 标记、标注，由于该翻译不能反映其特性，本文中，决定不对其进行翻译。</p>
<p><strong>那么<code>Callout</code> 是什么呢?</strong><br>在此先简单理解为，当过滤引擎检测到过滤条件为<code>TRUE</code>时，会触发相应行为，<code>Callout</code>则用于定义被触发的行为。</p>
<p>由此便可以将 <code>WFP</code> 驱动开发分为两个部分:</p>
<ol>
<li>将 <code>Callout</code> 添加到指定位置</li>
<li>定义 <code>Callout</code> 中的行为</li>
</ol>
<h2 id="Callout注册及反注册"><a href="#Callout注册及反注册" class="headerlink" title="Callout注册及反注册"></a><code>Callout</code>注册及反注册</h2><p>本文并不打算贴源码，只对关键函数进行说明，可配合文末<code>github</code>中的源码阅读。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ol>
<li>FwpmEngineOpen – 用于打开过滤引擎，返回一个句柄</li>
<li>FwpmTransactionBegin – 设置会话权限，设置为0即可</li>
<li>FwpsCalloutRegister – 注册 <code>Callout</code> 到过滤引擎，从其参数上看，也可看做绑定设备对象</li>
<li>FwpmCalloutAdd      – 正式向过滤引擎添加 <code>Callout</code>，与上面注册的 <code>Callout</code> 相关联</li>
<li>FwpmSubLayerAdd     – 添加一个子层(可以不添加)，通过控制子层的权重，使得本驱动的过滤模块更具话语权</li>
<li>FwpmFilterAdd       – 添加一个过滤器</li>
<li>FwpmTransactionCommit – 提交以上内容，在此函数被正确调用后，过滤正式生效</li>
<li>FwpmTransactionAbort – 在上述过程失败时进行回滚</li>
</ol>
<p>接下来将对其中重要的部分逐步说明<br><strong>第<code>3</code>步中</strong>，会用到结构<code>FWPS_CALLOUT</code>，其成员说明如下:<br><code>calloutKey</code> 对应一个 <code>GUID</code>，作为本 <code>Callout</code>的唯一标识<br><code>classifyFn</code> 会在触发过滤时被调用，可以在其中拦截&#x2F;放行当前操作。<br><code>flowDeleteNotifyFn</code> 会在数据流将终止且该数据流已关联上下文时被调用<br><code>notifyFn</code> 在加入或移除过滤器时触发。</p>
<p><strong>第<code>4</code>步中</strong>，会用到结构 <code>FWPM_CALLOUT</code>，其中关键成员说明如下:<br><code>applicableLayer</code> 指明该 <code>Callout</code> 适用于哪一个层。<br><code>calloutKey</code>对应到第三步中 <code>Callout</code> 的唯一标识，如此便能将本结构与第<code>3</code>步中的结构进行关联。</p>
<p><strong>第<code>5</code>步中</strong>，添加一个子层，并非必要操作，只是在添加子层后，能够更加灵活的控制过滤模块的位置。</p>
<p><strong>第<code>6</code>步中</strong>，会用到 <code>FWPM_FILTER</code> 结构，其中关键成员说明如下:<br><code>layerKey</code> 指明该过滤器被添加到哪个层，设置为与 <code>applicableLayer</code> 一致即可。<br><code>displayData</code> 字符描述，不重要<br><code>action.type</code> 指明过滤器的操作类型，通常使用 <code>FWP_ACTION_CALLOUT_TERMINATING</code> 或 <code>FWP_ACTION_CALLOUT_INSPECTION</code>，二者都会调用 <code>Callout</code>，区别在于是否允许阻止&#x2F;允许操作。<br><code>action.calloutKey</code> 第<code>3</code>步的 <code>GUID</code>，将过滤器与<code>Callout</code>关联，是否需要关联还取决于上面 <code>type</code>。<br><code>subLayerKey</code> 指定子层，如果第<code>5</code>步中，不添加新的子层，可以指定为系统默认子层<code>FWPM_SUBLAYER_UNIVERSAL</code>。<br><code>weight.type</code> 指定过滤器权重，将该type设置为 FWP_EMPTY，可以由系统自动分配权重。<br><code>numFilterConditions</code> 设置过滤条件个数，可以是零到多个。<br><code>filterCondition</code> 这是个结构体数组，可以在中间指定过滤条件，注意条件个数要与<code>numFilterConditions</code>一致。<br><code>filterConditions[0].fieldKey</code> 指明过滤的条件<br><code>filterConditions[0].matchType</code> 指明匹配的方式<br><code>filterConditions[0].conditionValue.type</code> 指明值的类型<br><code>filterConditions[0].conditionValue.v4AddrMask</code> 指明值，这是个联合体，应根据类型选定需要的成员</p>
<p>e.g.<br><code>A(条件) ==(匹配方式) B(值)</code></p>
<p>相关参考:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/embedded/gg157394%28v=winembedded.80%29">layer</a></li>
<li><a href="https://docs.microsoft.com/en-au/windows-hardware/drivers/network/using-bind-or-connect-redirection">Using Bind or Connect Redirection</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/embedded/gg157655%28v=winembedded.80%29">fieldKey</a></li>
</ul>
<h3 id="反注册"><a href="#反注册" class="headerlink" title="反注册"></a>反注册</h3><p>反注册为注册的逆过程，类似栈操作，先入后出</p>
<ol>
<li>FwpmFilterDeleteById</li>
<li>FwpmSubLayerDeleteByKey</li>
<li>FwpmCalloutDeleteById</li>
<li>FwpsCalloutUnregisterById</li>
<li>FwpmEngineClose</li>
</ol>
<p>因为很简单，本文就不说明了。</p>
<h2 id="Callout中的回调函数"><a href="#Callout中的回调函数" class="headerlink" title="Callout中的回调函数"></a><code>Callout</code>中的回调函数</h2><p>在上节中以及提到，<code>Callout</code>一共有<code>3</code>个回调函数可以供用户处理。</p>
<p>其中<br><code>notifyFn</code> 及 <code>flowDeleteNotifyFn</code>，应用较少，<br><code>flowDeleteNotifyFn</code> 在获取流数据时可以由它来最后回收资源。</p>
<p>关于绑定流句柄上下文的函数有:<br><code>FwpsFlowAssociateContext0 </code><br><code>FwpsFlowRemoveContext0</code></p>
<p>重点说一下 <code>classifyFn</code>，这个函数有<code>7</code>个参数，原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FwpsCalloutClassifyFn1</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> FWPS_INCOMING_VALUES0 *inFixedValues,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> FWPS_INCOMING_METADATA_VALUES0 *inMetaValues,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *layerData,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span> *classifyContext,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> FWPS_FILTER1 *`filter`,</span></span><br><span class="line"><span class="params">  UINT64 flowContext,</span></span><br><span class="line"><span class="params">  FWPS_CLASSIFY_OUT0 *classifyOut</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><code>inFixedValues</code> 包含网络数据信息，例如ip port等<br><code>inMetaValues</code> 元数据,包含和过滤相关的信息，其内成员并不都可用，需要配合宏<code>FWPS_IS_METADATA_FIELD_PRESENT</code>测试<br><code>layerData</code>    网络原始数据<br><code>classifyContext</code> 驱动的上下文信息<br><code>filter</code> 过滤器相关信息<br><code>flowContext</code> 流句柄关联的上下文信息<br><code>classifyOut</code> 返回值，可以在该结构的 <code>actionType</code> 中指示动作类型，诸如 拦截放行，下发到下层过滤器等操作。</p>
<h2 id="分层与子层"><a href="#分层与子层" class="headerlink" title="分层与子层"></a>分层与子层</h2><p>简单说一下分层与子层。<br>在读源码的时候我也困惑了一会，为何一个子层可以用于不同分层的过滤器。</p>
<img src="/2020/03/10/nt_driver_6/image-20221010190629752.png" class="" alt="image-20221010190629752">


<p>上图就是分层与子层之间的关系了。</p>
<p>事实上，每一个分层都会涵盖所有子层，也就是说子层是公用的。</p>
<h2 id="概览与总结"><a href="#概览与总结" class="headerlink" title="概览与总结"></a>概览与总结</h2><p>首先 WFP 分为两大组件，组件中又包含多个分层(过滤层)，每个分层中又涵盖所有子层，每个子层内又包含一定数量的过滤器，这些过滤器只会在其适配的模式下进行工作，<br>过滤器中又包含条件和 <code>Callout</code>，通过注册 <code>Callout</code>，就能对条件成立的数据包进行更细粒度的过滤。<br>过滤器中也可以不包含 <code>Callout</code> 仅根据条件进行过滤，又或是不包含条件，仅依赖 <code>Callout</code> 进行过滤。<br>如果都不包含，那这个过滤器就没意义了。</p>
<p>本文对 WFP 相关的知识只是进行了初步的介绍，剩下的细节仍旧需要根据实际的需求进一步学习。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>MSDN</li>
<li>各种各样的源码及文章</li>
<li><a href="https://github.com/JaredWright/WFPStarterKit/tree/master/Tutorial">github: JaredWright&#x2F;WFPStarterKit</a></li>
</ul>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>nt网络过滤(7)--NDIS</title>
    <url>/2020/03/10/nt_driver_7/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为本系列的最后一篇，将来聊一聊NDIS有关的话题。当然本文的话题也仅限于过滤。</p>
<p>NDIS 作为整套网络协议的最底层，过滤上有着得天独厚的“地理”优势，同样的也会给它带来麻烦。<br>在NDIS层做过滤，主要是为了嗅探或修改数据包，而不适合去做与进程直接打交道的应用，如防火墙等。</p>
<h2 id="NDIS"><a href="#NDIS" class="headerlink" title="NDIS"></a>NDIS</h2><img src="/2020/03/10/nt_driver_7/image-20221010190801287.png" class="" alt="image-20221010190801287">


<p>NDIS全称是网络驱动接口规范，其分为三个层</p>
<ul>
<li>NDIS 协议驱动</li>
<li>NDIS 中间层驱动 (NDIS过滤层驱动,在 NDIS 6.0 引入)</li>
<li>NDIS 小端口驱动</li>
</ul>
<p>NDIS协议驱动与TDI传输器相接，TDI传输器通过调用NDIS库函数来构造一个NDIS Packet，再将其发送给NDIS小端口驱动。</p>
<p>查了多份资料，NDIS协议驱动与TDI传输器看起来是一个整体的两个部分，上半部分负责和TDI层沟通，下半部分负责和NDIS层沟通。</p>
<p>NDIS中间层驱动是一个特殊的驱动程序，对于其上层模拟成小端口驱动，对其下层又模拟成协议驱动。<br>它必须同时满足上下两套驱动程序所要求的编程接口，以实现透明化。通常可以用它实现多适配器时的负载均衡，或是流量嗅探。</p>
<p>NDIS小端口驱动则负责管理网卡硬件及为上层提供接口。其不属于一个真正意义上的Windows 驱动程序，既不使用 Windows IO 管理器规范，也不接收处理 IRP，而是使用了一套自己实现的规范。</p>
<p><strong>NDIS过滤层驱动，也称为 NDIS过滤驱动，为了与传统意义上的过滤驱动做区分，本文统一译为NDIS过滤层驱动，其在 NDIS 6.0 引入，与中间层驱动的作用相当，但拥有更高的效率及更简单的接口。</strong></p>
<h2 id="NDIS过滤驱动现状"><a href="#NDIS过滤驱动现状" class="headerlink" title="NDIS过滤驱动现状"></a>NDIS过滤驱动现状</h2><p>由于NDIS过滤驱动在安装时会断一下网，这对于某些软件及某些环境都是是致命的。</p>
<p>例如在网吧无盘环境下，常规的 NDIS过滤驱动就不能正常工作。</p>
<p>折中方案又有 <code>NDIS HOOK</code> 等，但是 <code>NDIS HOOK</code> 存在明显的兼容性及稳定性问题，适用性不高。</p>
<p>而日常开发中，对于协议驱动和小端口驱动的开发需求及相关资料都相对较少，通常都有较为成熟的解决方案。</p>
<p>如果是自己通过NDIS中间层实现过滤驱动还涉及组包等问题，相对复杂。</p>
<p>本文没有信心能把中间层讲清楚，要实现一个中间层过滤驱动，还需要协议驱动和小端口驱动的相关知识。</p>
<h3 id="NDIS中间层与NDIS过滤层的抉择"><a href="#NDIS中间层与NDIS过滤层的抉择" class="headerlink" title="NDIS中间层与NDIS过滤层的抉择"></a>NDIS中间层与NDIS过滤层的抉择</h3><p>到底是该基于传统中间层驱动来写还是该基于新版的过滤层驱动来写。</p>
<p>传统的中间层驱动兼容性会相对好一点，但是复杂性会高出很多，要写一个传统的中间驱动，既要注册为小端口驱动，又要注册为协议驱动。<br>而过滤层驱动，只需要注册为过滤层驱动即可，从实现上要比中间层驱动简单一些。</p>
<p>在当前的微软驱动开发示例中，已经找不到中间层驱动了。</p>
<p><strong>出于篇幅考虑，本文就结合 <code>filter</code> 简单介绍一下过滤层驱动的编写方式及相关知识。</strong></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>NDIS过滤层驱动初始化与卸载</p>
<ol>
<li>构造 NDIS_FILTER_DRIVER_CHARACTERISTICS 结构</li>
<li>NdisFRegisterFilterDriver 注册为中间层驱动</li>
<li>NdisRegisterDeviceEx 添加用于通信的设备对象</li>
<li>NdisDeregisterDeviceEx</li>
<li>NdisFDeregisterFilterDriver</li>
</ol>
<p>在 NDIS_FILTER_DRIVER_CHARACTERISTICS 结构中又需要注册一组接口，正是通过这组接口来实现过滤。</p>
<p>一般来说，可以直接在 <code>filter</code> 的基础上进行二次开发，原本的 <code>filter</code> 中提供的接口是什么都不做的，需要由开发者挑选需要关注的接口自行实现。</p>
<p>中间一些关于状态和操作的内容这里就跳过。</p>
<p>在 NDIS_FILTER_DRIVER_CHARACTERISTICS 中，较为关注与数据包有关的接口：</p>
<ul>
<li>FilterReturnNetBufferLists</li>
<li>FilterReceiveNetBufferLists</li>
<li>FilterSendNetBufferListsComplete</li>
<li>FilterSendNetBufferLists</li>
</ul>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><img src="/2020/03/10/nt_driver_7/image-20221010190851303.png" class="" alt="image-20221010190851303">


<p>在 NDIS过滤层中，数据包以NET_BUFFER的形式存在，它是构成数据包的基本结构。</p>
<p>在每一个 NET_BUFFER 中拥有一个 MDL 链表。MDL 可以把数据缓冲区的地址映射到 NET_BUFFER 结构所指向的数据空间中。<br>由多个 NET_BUFFER 结构可以构成一个 NET_BUFFER_LIST。<br>在过滤层驱动中，就是依靠 NET_BUFFER_LIST 进行数据的发送与接收。</p>
<p>在获取数据包时，会用到一些相关的宏<br>1.  NET_BUFFER_FIRST_MDL         &#x2F;&#x2F; 获取第一个 MDL<br>2.  NET_BUFFER_DATA_OFFSET       &#x2F;&#x2F; 网络数据包内容偏移</p>
<p>1.  NET_BUFFER_CURRENT_MDL        &#x2F;&#x2F; 获取当前 MDL<br>2.  NET_BUFFER_CURRENT_MDL_OFFSET &#x2F;&#x2F; 获取当前 MDL 偏移以获取 Mac 帧的首地址</p>
<p>*. <code>NdisQueryMdl</code> &#x2F;&#x2F;可用于获取相关信息</p>
<h3 id="发送请求过滤"><a href="#发送请求过滤" class="headerlink" title="发送请求过滤"></a>发送请求过滤</h3><img src="/2020/03/10/nt_driver_7/image-20221010190911633.png" class="" alt="image-20221010190911633">


<p>接收请求的行为过滤，主要是对 FilterReceiveNetBufferLists 的 ReceiveFlags 参数进行处理。</p>
<h3 id="接收请求过滤"><a href="#接收请求过滤" class="headerlink" title="接收请求过滤"></a>接收请求过滤</h3><img src="/2020/03/10/nt_driver_7/image-20221010190927907.png" class="" alt="image-20221010190927907">


<p>发送请求的行为过滤与接收请求的处理流程类似。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在传递接收请求的时候，需要区分同步异步情况。针对这两种情况选择不同的处理方式。<br>略，可参考 《面向Win8操作系统的网络包过滤关键技术研究》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文写的过于简单仓促，由于篇幅限制，不能铺开来写，只能提供一个宏观上的印象。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://localhost/usr/uploads/2020/01/1681427991.pdf">面向Win8操作系统的网络包过滤关键技术研究</a></li>
<li><a href="http://localhost/usr/uploads/2020/01/3641122394.ppt">基于NDIS的网络编程</a></li>
<li><a href="https://docs.microsoft.com/en-au/windows-hardware/drivers/network/ndis-core-functionality2">MSDN相关文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>nt driver</tag>
      </tags>
  </entry>
  <entry>
    <title>程序性能优化</title>
    <url>/2022/10/22/program_performance_optimization/</url>
    <content><![CDATA[<p>结合这两天碰到的一个实例简单聊一下这个话题。</p>
<p>本文带有很强的主观意识，若和各位看官的想法冲突，请持有保留态度阅读。</p>
<span id="more"></span>

<hr>
<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><p>这两天帮一个老朋友优化了一份代码，<br>大致功能是windows下枚举系统的一些关键信息，<br>规整并输出到指定格式的文件中。</p>
<h2 id="选择合适的语言"><a href="#选择合适的语言" class="headerlink" title="选择合适的语言"></a>选择合适的语言</h2><p>在我的要求下，老朋友将代码发过来作为参考，<code>cpp</code> 实现，<br>大约有 <code>5000</code> 行代码，冗余严重，性能不容乐观。</p>
<p>这里出现了三个关键词，<code>cpp</code> 、<code>冗余</code>、<code>性能</code>。</p>
<h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><p><code>cpp</code> 被大部分人认为是接近 <code>c</code> 的底层语言。底层语言的性能通常较高，很多博客文章都会将其作为卖点而忽略了一个事实。</p>
<p><strong><code>cpp</code> 可以实现高性能程序，但不代表使用 <code>cpp</code> 实现的程序一定是高性能的。对应用该语言的人来说，通常使用 <code>cpp</code> 实现高性能、稳定的程序难度非常高。同时也很容易忽略一个问题，即程序本身是 <code>计算密集型</code> 还是 <code>IO密集型</code>，对于不同情景来说，<code>cpp</code> 未必是最适合的语言。</strong></p>
<p><a href="https://segmentfault.com/a/1190000039869861">Linus 时隔十一年再次抨击 C++ ：糟糕透顶！毫无用处！</a></p>
<p>就和 <code>linus</code> 多次吐槽 <code>cpp</code> 一样，由于其难度过高，很多开发者并不具备使用它的能力。一门语言在使用时应当是清晰的，透明的，其编码思路是编译器能理解并能提出相应建议的。<code>cpp</code> 显然在很多方面仍旧存在欠缺。</p>
<h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>另一方面，使用 <code>cpp</code> 时容易重复造轮子，更可怕是容易在不熟悉<code>系统框架</code>时造出一些性能低下的轮子，并直接作用于项目。</p>
<p>轮子本身是好的，通过实践深入系统架构，加深理解的同时也能推陈出新。只是当项目目标不在轮子本身这块时，使用成熟的第三方框架是明智的选择。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>俗话说，“底层语言抠细节，高层语言搞设计”（刚编的），安卓系统就是一个好例子，使用 <code>java</code> 和 <code>cpp</code> 分别去解决不同层面的问题。</p>
<p>前面提到了 <code>计算密集型</code> 还是 <code>IO密集型</code>。对于 <code>计算密集型</code>，当程序性能问题发生在大量复杂的运算中时，使用底层语言能减少抽象成本，生成出性能更好的指令。而对于 <code>IO密集型</code> 来说，程序自身的性能就不在首要位置了，大量的时间被消耗到了IO等待中。针对这一问题，系统层面又提出了多路复用等各种手段，简单的说，一是IO可用时去做IO，二是减少IO本身的开销，内存拷贝等，这些都是后话了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>cpp</code> 不是解决性能问题的万金油，应当从实际出发，选择更贴合目标的语言。</p>
<p>这也是老朋友为什么使用高性能语言却没能得到想要的高性能的主要原因之一。</p>
<h2 id="从哪里开始优化"><a href="#从哪里开始优化" class="headerlink" title="从哪里开始优化"></a>从哪里开始优化</h2><p>一般来说，不考虑重构的话，优化可以借助一些性能分析工具，通过对函数、方法的占用时间快速定位热点代码部分。</p>
<p>例如 <code>pprof</code> 或 <code>perf</code> 工具生成信息，windows可以使用vs自带的性能分析工具。</p>
<p>无论使用哪种工具，需要重点关注的都是比较耗时的操作在哪个函数或者调用中。</p>
<p>优化的方向主要有：</p>
<ol>
<li>函数结构、算法</li>
<li>框架或模型</li>
</ol>
<p>无论是哪种，都应该带着“它为什么会耗时，它有没有优化的可能或必要性”这样的问题进行探索。</p>
<p>另一种便是在考虑重构时，对需求重新分析，尽可能的一开始就避免低效的代码。</p>
<h2 id="编码前的思考"><a href="#编码前的思考" class="headerlink" title="编码前的思考"></a>编码前的思考</h2><p>在这个实例中，首先进行需求分析。</p>
<ol>
<li>枚举系统</li>
<li>规整数据</li>
<li>输出文件</li>
</ol>
<p>朋友在编写代码时，认为能通过多线程并发解决数据量过大的问题，故在代码中创建了很多的线程。</p>
<p>多线程是个双刃剑。<br>它能有效利用CPU资源，这在编译器中很常见，多线程编译会快上许多，在解决 <code>计算密集型</code> 程序时，能有效发挥作用。但随之会引出一个问题，多线程中使用共享资源的同步问题。需要考虑到锁本身的开销就很大，线程资源的维护也存在开销。</p>
<p><strong>线程并不是越多越好。可以考虑：</strong></p>
<p><em>进程时间片会分给线程，若线程过多，那么每个线程的有效时间就会减少，线程切换本身就会消耗一定的计算资源，若线程的有效时间过低，切换线程的开销就会被凸显。</em></p>
<p>回到需求，枚举系统是一个 <code>Native API</code> 调用过程，整理数据是一个计算过程，输出文件是一个 <code>IO</code> 过程。</p>
<p>核心如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">any <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        any data = enum_system();</span><br><span class="line">        data.translate(FMT);</span><br><span class="line">        data.write2file();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分类，前两个过程都可以使用多线程优化，第三个则需要对文件IO优化。</p>
<p>仔细思考，如果将IO操作放到线程中处理会引发什么问题？</p>
<p>没错数据同步问题，会出现多个线程对同一个文件的写入操作。</p>
<p>此时再将IO操作放到独立的线程中，将成为一个典型的 PV问题。</p>
<blockquote>
<p>有一个有限缓冲区和两个线程：生产者和消费者。他们分别不停地把产品放入缓冲区和从缓冲区中拿走产品。一个生产者在缓冲区满的时候必须等待，一个消费者在缓冲区空的时候也必须等待。另外，因为缓冲区是临界资源，所以生产者和消费者之间必须互斥执行。</p>
</blockquote>
<p>关于PV问题的文章有很多，本文就不啰嗦了。</p>
<p>接着便是文件IO操作如何优化的问题。<br>通常情况下，使用异步IO即可，只是windows下实现起来异常复杂。<br>另一种简单的办法便是减少IO次数，引入写缓冲机制，即在写缓冲未满时，写入会保存到缓冲区，直到数据总量超过缓冲区大小时再一次写出。<br>这种办法对于频繁的小数据写出格外有效，符合上面的需求。</p>
<p>接下来还需要考虑乱序问题，即写出的数据乱序该如何处理。一旦引入这个问题，多线程就不见得是好事，若放到内存中排序，则需要大量的内存来存放这些数据。若使用锁，那多线程将失去原有的意义。当然也可以通过一些中间件进行处理。</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>有位大师说过，要“避免过早的优化”，实时要求低的场景中，也许根本就不存在优化需求。</p>
<p>需求分析是很重要，对可接受的时间评估，如果能达到可接受范围，再考虑是否有迫切的优化需要。开始有一个预期，也能对后期优化指明方向，即对哪里可能存在的性能问题了然于胸。</p>
<p>对于某个底层调用非常耗时又不得不去使用时，在应用层面优化所产生的效益会大大降低。这种情景下，大佬们都会写底层的部分代码，针对某一部分特化处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，性能问题中没有“银弹”，需要到不同纬度中寻找答案，不能盲目使用语言或多线程等手段绕开，也不是一味的去优化算法，需要实事求是，从性能问题的源头出发稳扎稳打，否则会适得其反。</p>
]]></content>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>SOCKS5 代理?</title>
    <url>/2022/10/19/socks5/</url>
    <content><![CDATA[<p><code>SOCKS5</code> 代理，啥远古的东西了？</p>
<span id="more"></span>

<hr>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>昨天凑巧被问到这个，好久没碰过了，复习一下，希望能产出点东西。</p>
<h2 id="协议与状态机"><a href="#协议与状态机" class="headerlink" title="协议与状态机"></a>协议与状态机</h2><p>很多朋友一看到协议二字就紧张得不行，其实大可不必。</p>
<p>协议就是本质某种秩序，某种规则，在编排代码时按需即可。</p>
<p>就像是红灯停，绿灯行一样，他们是驾驶员与行人之间的协议，大家都遵守，就不会发生问题。</p>
<p>所有协议都可以被这么简化。</p>
<p>实际上现代计算机几乎所有的地方都离不开协议二字。</p>
<p>CPU上执行的二进制编码，可以视为硬件专家与软件专家之间的协议。</p>
<p>双击图标就能打开，是产品设计者与用户之间的协议。</p>
<p>。。。。或大或小，他们无处不在。</p>
<p>而 <code>SOCKS5</code> 则是一种用于网络代理的协议，仅此而已。</p>
<p>为了代理，很容易就能想到，他们二者有约定俗成的结构编排方式，其内部会包含一些信息。</p>
<p>同时，为了在不同阶段处理不同种类形式的任务，会告知对方需要做什么。</p>
<p>简单说就是一种状态的改变。为了降低这种状态转换时的心智负担，往往协议会伴随 <code>状态机</code> 一起出现，</p>
<p><code>状态机</code> 可以被简单的认为是一种描述状态迁移过程的机器，虽然有着高大上的名字，但本质不复杂。</p>
<p>本文后面会给出一个 <code>SOCKS5</code> 的状态机模型。</p>
<p>先看一个伪代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">any s = S0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    s = s==S0 ? S1:S0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对，你没看错，这就是最最简单的状态机模型了。</p>
<p>描述一下：</p>
<ul>
<li>当 S 位于 s0 状态时，啥都不干，并迁移到 s1 状态。</li>
<li>否则，啥都不干，迁移到 s0</li>
</ul>
<p>像不像一个来回拨动的按钮？</p>
<p>无论是说起来多么高大上的协议，最终也逃不过这个最简单的框架，妙哇~</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>再说一下代理，这个就是字面意思，举个形象的例子。</p>
<ul>
<li>A 写了封信交给 B，B 再交给 C，他把回信也交给 B，最后由 B 交给 A 就是一个典型的代理过程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C</span><br><span class="line">A &lt;- B &lt;- C</span><br></pre></td></tr></table></figure>

<p>这个过程中，B 会被称为中间人，而 <code>SOCKS5 server</code> 正是这种中间代理人的存在。</p>
<p>那么问题来了。</p>
<ol>
<li>刚才只有 A，那假如 D、E、F 也想让 B 帮忙送信怎么办?</li>
<li>如果 A 要送给 G、H、I 怎么办？</li>
</ol>
<p>那就需要和 B 协商要将信交给谁，信被回复时也会原路返回。 源头和目标之间就像 <code>隧道</code>一样连接起来。</p>
<p>再复杂化一点，假如 <code>B</code> 有好多个版本，类似于邮政、顺丰… 你到邮政版的 B 那里寄出顺丰，他当然不会帮到咯。</p>
<p>上述过程就可以直接被代入到具体的 <code>SOCKS5</code> 协议中，大概有了一个<code>代理协议</code>的雏形。</p>
<h2 id="SOCKS5-协议"><a href="#SOCKS5-协议" class="headerlink" title="SOCKS5 协议"></a>SOCKS5 协议</h2><p>协议简单，资料很多，大同小异。</p>
<p>为了避免熵增，节能减排，扒拉一个排版干净的放这，就不再赘述。</p>
<p><a href="https://zhuanlan.zhihu.com/p/458173597">Socks5 协议简介</a></p>
<h2 id="核心框架实现"><a href="#核心框架实现" class="headerlink" title="核心框架实现"></a>核心框架实现</h2><p>下图来自： <a href="https://segmentfault.com/a/1190000038498680">Socks5 代理协议详解 &amp; 基于 Netty 的实现</a></p>
<img src="/2022/10/19/socks5/1.png" class="" alt="socks5时序图">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 启动网络框架</span></span><br><span class="line">srv.loop(connRead, connWrite, connConnect ......);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接事件</span></span><br><span class="line">connConnect() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写事件</span></span><br><span class="line">connWrite() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读事件</span></span><br><span class="line">connRead(current_conn) &#123;</span><br><span class="line">    do_next(current_conn, current_conn.dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_parse_s5_request(src) &#123;</span><br><span class="line"></span><br><span class="line">    assert (src.must_local());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 提取 ip : port</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remote = connect(ip, port);</span></span><br><span class="line">    <span class="comment">// 设置默认状态为转发，如有读事件发生，直接转发即可</span></span><br><span class="line">    src.dst = connect(...);</span><br><span class="line">    src.dst.is_remote = <span class="number">1</span>;</span><br><span class="line">    src.dst.status = do_streaming;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 src 和 dst 都能知道对方的存在，建立了二者关联的隧道</span></span><br><span class="line">    make_tunnel(src, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据转发</span></span><br><span class="line">do_streaming(src, dst) &#123;</span><br><span class="line">    src.write(dst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_handshake(src) &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// do_handshake</span></span><br><span class="line">    src.status = session_handshake_auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_handshake_auth(src) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// do_handshake_auth</span></span><br><span class="line">    src.status = xxxx; <span class="comment">// 迁移到下一个状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机</span></span><br><span class="line">do_next (src, dst) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">        <span class="keyword">case</span> session_handshake: &#123;</span><br><span class="line">            do_handshake(src);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> session_handshake_auth: &#123;</span><br><span class="line">            do_handshake_auth(src);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">case</span> session_s5_request: &#123;</span><br><span class="line">            do_parse_s5_request(src);  <span class="comment">// 在获取到必要的信息后, 就可以建立隧道了</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> session_streaming: &#123;</span><br><span class="line">            do_streaming(src, dst);         <span class="comment">// 数据转发, 将数据来回倒腾即可</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上文伪代码部分实现了一个大致的框架，大致流程如此。</p>
<p>除了数据转发外，其它的网络事件也需要同时处理二者，例如 local 断开后，remote 也应断开。</p>
<h2 id="UDP-ASSOCIATE"><a href="#UDP-ASSOCIATE" class="headerlink" title="UDP ASSOCIATE?"></a>UDP ASSOCIATE?</h2><p>啥都不是，散会。</p>
<h2 id="到此为止"><a href="#到此为止" class="headerlink" title="到此为止"></a>到此为止</h2><p>虽然还想多讲一会儿，</p>
<p>但是这个东西实在是没有太多值得提的，到此为止吧，毁灭吧。</p>
]]></content>
      <tags>
        <tag>SOCKS5</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5 游戏资源解包与逆向工程实践分享</title>
    <url>/2026/01/09/ue5_asset_unpack_reverse/</url>
    <content><![CDATA[<p>UE 系列游戏的资源解包在大多数情况下并不复杂，但一旦进入非标准实现，就不可避免地需要结合源码、逆向与调试手段。<br>希望这次实践记录，能为遇到类似问题的读者提供一些思路与参考。</p>
<span id="more"></span>

<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>已经很久没有更新博客了。<br>最近有朋友找我帮忙看看某个游戏是否有办法进行资源解包，在研究和实践的过程中，发现过程还挺有意思的。与此同时，网上关于 <strong>UE5 游戏资源解包与逆向工程</strong> 的系统性讨论并不算多，于是决定整理一下经验，分享出来，和大家一起学习与交流。</p>
<p>话不多说，直接进入正题。</p>
<hr>
<h2 id="UE-系列游戏的常规解包思路"><a href="#UE-系列游戏的常规解包思路" class="headerlink" title="UE 系列游戏的常规解包思路"></a>UE 系列游戏的常规解包思路</h2><p>针对 Unreal Engine（UE）系列游戏，社区中已经有不少成熟且稳定的工具链。<br>下面简单介绍常用的解包工具，以及部分引擎级的逆向辅助工具。</p>
<hr>
<h3 id="常用解包工具"><a href="#常用解包工具" class="headerlink" title="常用解包工具"></a>常用解包工具</h3><ul>
<li><p><strong><a href="https://github.com/GHFear/AESDumpster">AESDumpster</a></strong><br>一键从内存中提取 UE 游戏所使用的 <strong>AES Key</strong>，对新手非常友好。</p>
</li>
<li><p><strong><a href="https://github.com/4sval/FModel">FModel</a></strong><br>非常著名的 UE 资源浏览与导出工具，支持 UE4 &#x2F; UE5，多数场景下即开即用。</p>
</li>
<li><p><strong><a href="https://github.com/FabianFG/CUE4Parse">CUE4Parse</a></strong><br>FModel 底层所依赖的核心解析库，负责 Pak 文件解析与解密，是 UE 资源解包的核心组件。</p>
</li>
<li><p><strong>UModel（UE Viewer）</strong><br>老牌 UE 资源浏览工具，稳定可靠，但支持 UE5 的版本通常需要额外寻找或自行编译。</p>
</li>
<li><p><strong>UnrealPak</strong><br>Unreal Engine 官方自带的 Pak 打包 &#x2F; 解包工具，通常随引擎源码或安装包提供。</p>
</li>
<li><p><strong>UnrealLocres</strong><br>用于解包与处理 UE 语言资源（<code>.locres</code>）文件，常见于本地化与汉化相关场景。</p>
</li>
</ul>
<blockquote>
<p>如果只是进行常规的 UE 游戏资源查看与导出，上述工具基本已经可以满足大多数需求。<br><a href="https://azhuge233.com/unreal-engine-%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96/">Unreal Engine 游戏资源提取</a><br>一文中对这些工具的使用方式做了较为详细的介绍，可作为补充阅读参考。</p>
</blockquote>
<p>需要注意的是，当涉及 <strong>游戏修改、汉化或资源回封</strong> 时，通常还需要配合使用<br><code>UnrealPak</code>、<code>UnrealLocres</code> 等工具，并且往往需要绕过 <strong>Pak 完整性校验、签名校验或额外的反篡改逻辑</strong>。<br>这部分内容与具体项目实现关系较大，本文不作展开，建议根据实际情况自行分析。</p>
<hr>
<h3 id="工具示意图"><a href="#工具示意图" class="headerlink" title="工具示意图"></a>工具示意图</h3><blockquote>
<p><strong>AESDumpster 运行界面</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/R1280x0.png" class="" alt="R1280x0">

<blockquote>
<p><strong>FModel &#x2F; CUE4Parse 加载 Pak 资源界面</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/R1280x0-2.png" class="" alt="R1280x0-2">

<blockquote>
<p><strong>基础使用流程示意</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/Snipaste_2025-05-04_12-10-26.png" class="" alt="Snipaste_2025-05-04_12-10-26">

<hr>
<h3 id="引擎-逆向辅助工具（进阶）"><a href="#引擎-逆向辅助工具（进阶）" class="headerlink" title="引擎 &#x2F; 逆向辅助工具（进阶）"></a>引擎 &#x2F; 逆向辅助工具（进阶）</h3><p>以下工具更多用于 <strong>引擎级分析、逆向工程、功能植入或 Mod 开发</strong>，并非纯解包所必需，但在复杂或非标准实现中非常有价值。</p>
<ul>
<li><p><strong><a href="https://github.com/piz-ewing/yinjector">yinjector</a></strong><br>轻量级 DLL 注入器，常用于注入调试代码、Hook 或自定义逻辑。</p>
</li>
<li><p><strong><a href="https://github.com/Encryqed/Dumper-7">Dumper-7</a></strong><br>Unreal Engine 游戏的 SDK 生成工具，支持 <strong>UE4 与 UE5</strong>，可用于生成 SDK、提取 <code>.usmap</code> 等反射与结构映射信息。</p>
</li>
<li><p><strong><a href="https://github.com/UE4SS-RE/RE-UE4SS">RE-UE4SS</a></strong><br>常用于制作 Mod 或植入自定义功能的工具，可扩展 UE 游戏运行时能力。</p>
</li>
<li><p><strong><a href="https://github.com/piz-ewing/PalWorld-Server-Unoffical-Api">PalWorld-Server-Unoffical-Api</a></strong><br>基于 UE 的能力扩展示例项目，可作为理解 UE 运行时交互与功能注入的参考。</p>
</li>
</ul>
<hr>
<h2 id="非标准解包场景下的逆向工程基础"><a href="#非标准解包场景下的逆向工程基础" class="headerlink" title="非标准解包场景下的逆向工程基础"></a>非标准解包场景下的逆向工程基础</h2><p>在实际分析中，并非所有 UE 游戏都遵循引擎的默认实现，常见的非标准情况包括：</p>
<ul>
<li>常规工具提取到的 Key 错误或不完整</li>
<li>AES Key 在运行时动态生成或多阶段派生</li>
<li>使用了自定义 Pak 加载器或对 Pak 进行了二次封装</li>
<li>修改或替换了原有的加密或校验算法</li>
</ul>
<p>在这些场景下，常规解包工具往往会失效，需要结合逆向工程手段，从引擎实现与游戏自身逻辑入手进行分析。</p>
<hr>
<h3 id="手动提取-AES-Key-的思路"><a href="#手动提取-AES-Key-的思路" class="headerlink" title="手动提取 AES Key 的思路"></a>手动提取 AES Key 的思路</h3><p>当自动化工具（如 AESDumpster）无法直接提取 AES Key 时，通常需要通过 <strong>静态分析与动态调试</strong> 手动定位 Key 的真实来源，常见思路包括：</p>
<ul>
<li>从 UE 的 Pak 加载与解密流程入手，重点关注<br><code>FPakPlatformFile</code>、<code>FPakFile</code>、<code>FAES::DecryptData</code> 等关键类与函数</li>
<li>通过字符串特征、结构体布局或函数交叉引用（Xref），追踪 AES Key 的初始化、传递与使用路径</li>
<li>在运行时对关键函数或关键数据写入位置下断点，观察 Key 的生成、拼接、解码或派生过程</li>
<li>结合内存 Dump，在合适的时机直接提取内存中的明文 Key，或其最终用于解密的派生结果</li>
</ul>
<p>以下是两篇非常值得参考的资料，详细讲解了 AES Key 的定位与 Dump 方法：</p>
<ul>
<li><p><strong>英文</strong><br><a href="https://stillu.cc/infosec/2021/03/01/obtaining-unreal-pak-decryption-key/">How I Extracted an Unreal Engine Game’s WWise Audio</a></p>
</li>
<li><p><strong>中文</strong><br><a href="https://blog.bzi-han.top/2024/08/10/%E9%80%86%E5%90%91-UE%E6%B8%B8%E6%88%8FPak%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%8C%85%E5%92%8C%E6%89%93%E5%8C%85%E4%B8%8EAES-Key%E7%9A%84%E5%AF%BB%E6%89%BE-Dump/">UE 游戏 Pak 文件的解包和打包与 AES Key 的寻找（Dump）</a></p>
</li>
</ul>
<hr>
<h3 id="逆向分析常用手段"><a href="#逆向分析常用手段" class="headerlink" title="逆向分析常用手段"></a>逆向分析常用手段</h3><p>在非标准解包场景中，通常需要结合以下工具与方法：</p>
<ul>
<li><p><strong>静态分析</strong>：IDA &#x2F; Ghidra<br>用于还原 UE 版本对应的 Pak 加载与解密逻辑，理解函数调用关系与数据流向。</p>
</li>
<li><p><strong>动态调试</strong>：x64dbg &#x2F; WinDbg<br>用于验证静态分析结论，观察运行时 Key 的生成、使用与销毁时机。</p>
</li>
</ul>
<hr>
<h2 id="实践之某非标准加密资源提取"><a href="#实践之某非标准加密资源提取" class="headerlink" title="实践之某非标准加密资源提取"></a>实践之某非标准加密资源提取</h2><p>本节记录一次真实项目中，针对 <strong>非标准 Pak 加密实现</strong> 的资源提取与逆向分析过程。</p>
<hr>
<h3 id="确认引擎版本与源码准备"><a href="#确认引擎版本与源码准备" class="headerlink" title="确认引擎版本与源码准备"></a>确认引擎版本与源码准备</h3><p>分析开始前，首先需要确认目标程序对应的 Unreal Engine 版本，以便后续对照引擎源码。</p>
<p>常见的确认方式有两种：</p>
<ol>
<li><p>使用<br><a href="https://illusory.dev/aesdumpster/">AES Dumpster – Unreal Engine AES Key Scanner</a><br>将游戏主程序拖入，即可识别其 UE 版本信息。</p>
</li>
<li><p>在 <code>Binaries\Win64</code> 或 <code>Engine\Binaries\Win64</code> 目录下找到游戏 <code>exe</code>，通过文件属性查看版本信息。</p>
</li>
</ol>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109010601200.png" class="" alt="image-20260109010601200">

<p>确认版本后，建议阅读官方文档<br><a href="https://www.unrealengine.com/en-US/ue-on-github">Unreal Engine on GitHub</a>，<br>并在 GitHub 上获取对应版本的 Unreal Engine 源码（需 Epic 授权），这对后续逆向分析非常有帮助。</p>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109003349998.png" class="" alt="image-20260109003349998">

<p>在资源解包相关场景中，通常重点关注以下目录：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Engine/Source/Runtime/PakFile/Private/</span><br></pre></td></tr></table></figure>

<p>其中较为关键的文件包括：</p>
<ul>
<li><p><strong>IPlatformFilePak.cpp</strong><br>Pak 解密逻辑，包含 <code>DecryptData</code></p>
</li>
<li><p><strong>PakFile.cpp</strong><br>Pak 结构解析核心，包含 <code>LoadIndex</code>、<code>LoadIndexInternal</code></p>
</li>
<li><p><strong>SignedArchiveReader.cpp</strong><br>Pak 索引相关的序列化逻辑，核心函数为 <code>Serialize</code></p>
</li>
</ul>
<p>这些文件基本覆盖了 Pak 文件的加载与解密流程。</p>
<hr>
<h3 id="AES-Key-定位"><a href="#AES-Key-定位" class="headerlink" title="AES Key 定位"></a>AES Key 定位</h3><p>在确认源码结构后，下一步是定位 AES Key。</p>
<p>通过在 x64dbg 中对主模块进行字符串搜索，可以较快定位到 Pak 解密相关函数，在其调用前后下断点进行跟踪。</p>
<blockquote>
<p><strong>源码中的 Key 使用位置</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109011026176.png" class="" alt="image-20260109011026176">
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109010920291.png" class="" alt="image-20260109010920291">

<blockquote>
<p><strong>x64dbg 中的表现</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/a806ab35da0a3332326e46fee23f4438f8f3bcb78466d7b3f4b596588871d6de.png" class="" alt="a806ab35da0a3332326e46fee23f4438f8f3bcb78466d7b3f4b596588871d6de">
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109041345461.png" class="" alt="image-20260109041345461">
<p>断点（<code>FAES::DecryptData</code>）触发后可以观察到，<code>r8</code>（第三个参数）指向 AES Key。<br>通常 AES Key 的长度为 <strong>16 的倍数</strong>，实际项目中多为 <strong>32 字节</strong>。</p>
<p>进一步分析可以发现，用于获取 Key 的 <code>GetPakEncryptionKey</code> 已被编译器内联，因此在反汇编中不会以独立函数形式出现。</p>
<hr>
<h3 id="解包流程与-CUE4Parse-修正"><a href="#解包流程与-CUE4Parse-修正" class="headerlink" title="解包流程与 CUE4Parse 修正"></a>解包流程与 CUE4Parse 修正</h3><p>将获取到的 Key 填入 <strong>FModel</strong> 进行快速验证，如果能直接解包，问题基本结束。<br>本例中验证失败，说明 Pak 结构或解密流程并非标准实现。</p>
<p>从零开始编写 Pak 解析器成本较高，因此这里选择在<br><strong><a href="https://github.com/FabianFG/CUE4Parse">CUE4Parse</a></strong> 的基础上进行修正。</p>
<h4 id="环境调整"><a href="#环境调整" class="headerlink" title="环境调整"></a>环境调整</h4><ul>
<li>将 <code>CUE4Parse.Example</code> 设为启动项目</li>
<li><code>Program.cs</code> 原用于 APK 解包，可将其 <code>Main</code> 重命名</li>
<li>将 <code>Unpacker.cs</code> 的入口方法改为 <code>Main</code></li>
<li>在代码中手动设置：<ul>
<li><code>_archiveDirectory</code></li>
<li><code>_aesKey</code></li>
<li>Pak 文件名</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Unpacker.cs 结构说明</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109012226880.png" class="" alt="image-20260109012226880">

<p>运行后即可动态跟踪解包流程。<br>需要注意的是，<code>OodleHelper</code> 相关依赖在网络环境较差时可能下载失败，<br>可手动下载并放置到对应目录，否则将无法正常解压。</p>
<hr>
<h4 id="GameType-定义与索引修正"><a href="#GameType-定义与索引修正" class="headerlink" title="GameType 定义与索引修正"></a>GameType 定义与索引修正</h4><p>由于标准版本配置无法正确解析该游戏的 Pak，通常需要新增一个 <code>GameType</code>。</p>
<p>可以参考 <code>EGame.GAME_UE5_6</code> 的定义，在对应版本附近添加新的游戏类型。</p>
<blockquote>
<p><strong>GameType 定义位置示意</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109012629419.png" class="" alt="image-20260109012629419">

<p>在代码层面，重点关注以下关键位置与调用流程：</p>
<ul>
<li><p><strong><code>CUE4Parse\UE4\Pak\PakFileReader.cs</code></strong><br>主要调用链：<br><code>PakFileReader</code> → <code>FPakInfo.ReadFPakInfo</code> → <code>new FPakInfo</code><br>需要逐项核对 Pak Header 中的 <strong>偏移、大小等字段信息</strong>。</p>
</li>
<li><p><strong><code>CUE4Parse\FileProvider\Vfs\AbstractVfsFileProvider.cs</code></strong><br>主要调用链：<br><code>SubmitKeysAsync</code> → <code>MountTo</code> → <code>PakFileReader.Mount</code><br>→ <code>ReadIndexUpdated</code> → <code>ReadAndDecryptIndex</code></p>
</li>
</ul>
<p>在流程正确的情况下，索引成功解密后即可完成 Pak 挂载。<br>如果 Pak 结构被修改较多，后续相关偏移同样需要同步修正。</p>
<p>通常可以认为，<strong>除加密方式与偏移调整外，不会对虚拟文件系统结构做大规模改动</strong>，<br>否则实现复杂度、兼容风险与维护成本都会显著增加。</p>
<hr>
<h3 id="同步逆向与加载流程确认"><a href="#同步逆向与加载流程确认" class="headerlink" title="同步逆向与加载流程确认"></a>同步逆向与加载流程确认</h3><blockquote>
<p>IDA 中的参考</p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109015153547.png" class="" alt="image-20260109015153547">

<p>通过 Pak 中的字符串特征，可以在 IDA 中快速定位到<br><code>Initialize</code>、<code>LoadIndex</code>、<code>LoadIndexInternal</code> 等关键函数。</p>
<p>Pak 的整体加载流程基本围绕上述函数展开，是后续动态跟踪与<br>偏移校对的主要切入点。</p>
<p>将关键偏移带回 x64dbg 中进行动态跟踪，逐项核对以下内容：</p>
<ul>
<li>Pak 头部与索引结构字段</li>
<li>各结构在文件中的偏移与大小</li>
<li>数据对齐与填充规则</li>
<li>解密前后的数据内容</li>
</ul>
<p>并与 CUE4Parse 中对应实现进行逐一比对，以修正解析逻辑。</p>
<p>需要说明的是，这一步骤本身非常枯燥且繁琐，虽然描述看似简单，<br>但在实际操作中往往是整个流程中<strong>最耗时</strong>的部分。</p>
<hr>
<h4 id="调试时机问题与解决方案"><a href="#调试时机问题与解决方案" class="headerlink" title="调试时机问题与解决方案"></a>调试时机问题与解决方案</h4><p>程序通常由根目录下的 <code>Launcher</code> 负责拉起，<br>因此无法直接调试 <code>Binaries\Win64</code> 下的主程序，只能在进程运行后附加调试。</p>
<p>尝试在 <code>Initialize</code> 下断点后，多次运行未能命中。</p>
<p>此时通常存在两种可能：</p>
<ol>
<li>调试器附加时机过晚</li>
<li>使用了非标准 Pak 加载流程</li>
</ol>
<p>一种快速验证方式是，将其他 UE 游戏的 Pak 拷贝到当前目录以触发解密失败错误。<br>通过错误信息与调用堆栈，可以间接观察内部加载逻辑。</p>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109024317328.png" class="" alt="image-20260109024317328">

<p>本例中属于第一种情况。</p>
<p>为尽可能提前介入调试，可以采用多种方式，例如在 <code>Launcher</code> 中拦截进程创建并以挂起方式启动。</p>
<p>这里更推荐使用 <strong>DLL 搜索顺序劫持注入</strong> 的方法，在游戏目录下放置伪造的系统 DLL（如 <code>winhttp.dll</code>），</p>
<p>可借助 <code>AheadLib</code> 快速生成对应的劫持代码。</p>
<blockquote>
<p><strong>注入验证示例</strong></p>
</blockquote>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109024437399.png" class="" alt="image-20260109024437399">

<p>游戏启动后会被 <code>MessageBox</code> 阻塞，此时附加调试即可早于 Pak 加载阶段，从而完整跟踪 <code>LoadIndex</code> 流程。</p>
<hr>
<h3 id="加密算法异常与替代方案"><a href="#加密算法异常与替代方案" class="headerlink" title="加密算法异常与替代方案"></a>加密算法异常与替代方案</h3><p>在逐步修正索引与偏移等解析细节后，执行到 <code>DecryptData</code> 阶段，<br><code>CUE4Parse</code> 在 <code>IsValidIndex</code> 中抛出异常，这提示 <strong>解密算法并非标准 AES</strong>。</p>
<p>从调试器中提取：</p>
<ul>
<li>Cipher</li>
<li>Key</li>
</ul>
<p>并编写测试代码进行验证：</p>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109031425328.png" class="" alt="image-20260109031425328">

<p>测试结果与 CUE4Parse 的解密结果一致，但与游戏内部解密结果不一致。<br>说明该算法在形式上接近 AES，但内部实现存在改动。</p>
<p>常规做法是完整逆向算法与密码表，但成本较高。<br>本例中采用另一种思路：<strong>直接复用游戏自身的解密函数</strong>。</p>
<p>通过在前述 DLL 劫持注入基础上，实现一套简易 RPC 接口，将解密请求转发给游戏进程内部执行（具体实现见附录）。</p>
<p>最终，CUE4Parse 的解密流程直接调用游戏原生逻辑，验证成功。</p>
<img src="/2026/01/09/ue5_asset_unpack_reverse/image-20260109035330472.png" class="" alt="image-20260109035330472">

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一次实际的资源解包需求出发，记录了在常规工具失效的情况下，<br>如何逐步介入 UE5 游戏的 Pak 加载与解密流程。</p>
<p>从确认 UE 版本、定位 Pak 结构与加载路径，到修正解析偏移、同步逆向验证，<br>再到处理非标准 AES 加密并复用游戏内解密逻辑，整个流程环环相扣，循序推进。</p>
<p>UE 系列游戏的资源解包在大多数情况下并不复杂，但一旦进入非标准实现，<br>就不可避免地需要结合源码、逆向与调试手段。<br>希望这次实践记录，能为遇到类似问题的读者提供一些思路与参考。</p>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="游戏端"><a href="#游戏端" class="headerlink" title="游戏端"></a>游戏端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">MainEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">MessageBoxA</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="string">&quot;Start TCP server?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Confirm&quot;</span>,</span><br><span class="line">        MB_OKCANCEL | MB_ICONQUESTION</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != IDOK)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 取消</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">thread</span>([] &#123;</span><br><span class="line">        <span class="comment">// 初始化 WinSock</span></span><br><span class="line">        WSADATA wsa;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        SOCKET server = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">        <span class="keyword">if</span> (server == INVALID_SOCKET)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sockaddr_in addr&#123;&#125;;</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">        addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(server, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == SOCKET_ERROR)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">listen</span>(server, SOMAXCONN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key</span></span><br><span class="line">        <span class="type">static</span> <span class="type">uint8_t</span> key[<span class="number">32</span>] = &#123;</span><br><span class="line">            <span class="number">0</span>x??, ...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">uintptr_t</span> module_base = (<span class="type">uintptr_t</span>)<span class="built_in">GetModuleHandleA</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">uintptr_t</span> func_addr = module_base + fake_aes_rva;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> __int64(__fastcall* <span class="type">fake_aes_t</span>)(</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">char</span>* edata,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">int</span>   len,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">char</span>* key</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">fake_aes_t</span> fake_aes = (<span class="type">fake_aes_t</span>)func_addr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> handle_client = [fake_aes](SOCKET client) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 先接收 4 字节长度</span></span><br><span class="line">                <span class="type">uint32_t</span> net_len = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">recv</span>(client, (<span class="type">char</span>*)&amp;net_len, <span class="built_in">sizeof</span>(net_len), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">uint32_t</span> len = <span class="built_in">ntohl</span>(net_len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="built_in">buffer</span>(len);</span><br><span class="line">                <span class="type">size_t</span> received = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (received &lt; len) &#123;</span><br><span class="line">                    <span class="type">int</span> ret = <span class="built_in">recv</span>(client, (<span class="type">char</span>*)buffer.<span class="built_in">data</span>() + received, len - received, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">                    received += ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解密</span></span><br><span class="line">                <span class="built_in">fake_aes</span>(buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送长度 + 数据</span></span><br><span class="line">                <span class="type">uint32_t</span> send_len = <span class="built_in">htonl</span>((<span class="type">uint32_t</span>)buffer.<span class="built_in">size</span>());</span><br><span class="line">                <span class="built_in">send</span>(client, (<span class="type">char</span>*)&amp;send_len, <span class="built_in">sizeof</span>(send_len), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">send</span>(client, (<span class="type">char</span>*)buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        cleanup:</span><br><span class="line">            <span class="built_in">closesocket</span>(client);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环接收客户端</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            SOCKET client = <span class="built_in">accept</span>(server, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (client != INVALID_SOCKET) &#123;</span><br><span class="line">                std::<span class="built_in">thread</span>(handle_client, client).<span class="built_in">detach</span>(); <span class="comment">// 简易的多线程处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">closesocket</span>(server);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CUE4Parse端"><a href="#CUE4Parse端" class="headerlink" title="CUE4Parse端"></a><code>CUE4Parse</code>端</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> CUE4Parse.UE4.VirtualFileSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CUE4Parse.GameTypes.XX.Encryption.Aes</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">XXAes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 全局 TcpClient + NetworkStream</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> TcpClient Client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> NetworkStream Stream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> LockObj = <span class="keyword">new</span> <span class="built_in">object</span>(); <span class="comment">// 多线程安全</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">XXAes</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 全局只有一个套接字，避免过多的消耗客户端端口</span></span><br><span class="line">        Client = <span class="keyword">new</span> TcpClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        Stream = Client.GetStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">XXDecrypt</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">byte</span>[] bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> beginOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">bool</span> isIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">        IAesVfsReader reader</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// UE 允许空块</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Array.Empty&lt;<span class="built_in">byte</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes.Length &lt; beginOffset + count)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(</span><br><span class="line">                <span class="string">&quot;beginOffset + count is larger than the length of bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">0xF</span>) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;count must be a multiple of 16&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取 slice</span></span><br><span class="line">        <span class="built_in">byte</span>[] slice = <span class="keyword">new</span> <span class="built_in">byte</span>[count];</span><br><span class="line">        Buffer.BlockCopy(bytes, beginOffset, slice, <span class="number">0</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 套接字锁，单套接字并发需额外设计，此处直接用锁</span></span><br><span class="line">        <span class="keyword">lock</span> (LockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 发送长度 + 数据</span></span><br><span class="line">                <span class="built_in">byte</span>[] lenBytes = BitConverter.GetBytes(</span><br><span class="line">                    System.Net.IPAddress.HostToNetworkOrder(slice.Length)</span><br><span class="line">                );</span><br><span class="line">                Stream.Write(lenBytes, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">                Stream.Write(slice, <span class="number">0</span>, slice.Length);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收长度</span></span><br><span class="line">                <span class="built_in">byte</span>[] recvLenBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>];</span><br><span class="line">                <span class="built_in">int</span> read = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (read &lt; <span class="number">4</span>)</span><br><span class="line">                    read += Stream.Read(recvLenBytes, read, <span class="number">4</span> - read);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> recvLen = System.Net.IPAddress.NetworkToHostOrder(</span><br><span class="line">                    BitConverter.ToInt32(recvLenBytes, <span class="number">0</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (recvLen &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> Array.Empty&lt;<span class="built_in">byte</span>&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收解密后的数据</span></span><br><span class="line">                <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[recvLen];</span><br><span class="line">                read = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (read &lt; recvLen)</span><br><span class="line">                    read += Stream.Read(buffer, read, recvLen - read);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Socket decrypt failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>UE5 逆向工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐MP3地址解密</title>
    <url>/2020/01/10/yun_music_cryptor/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在改博客的音乐插件时，发现其是向<br><code>https://api.i-meto.com/meting/api</code><br>查询网易的mp3地址，考虑到它不刷 <code>listid</code> 缓存，以后可能会有自己实现的需求，遂对网易云音乐分析了一番。</p>
<h2 id="云音乐MP3地址分析"><a href="#云音乐MP3地址分析" class="headerlink" title="云音乐MP3地址分析"></a>云音乐MP3地址分析</h2><h3 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h3><p>打开 <code>fiddler</code> 抓一组包，很容易找到包含音乐地址的包。</p>
<img src="/2020/01/10/yun_music_cryptor/image-20221010180900107.png" class="" alt="image-20221010180900107">

<p>得到获取地址的接口为<br><code>https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=</code></p>
<p>简单分析请求之后，得到一组最简洁的请求格式</p>
<img src="/2020/01/10/yun_music_cryptor/image-20221010180914111.png" class="" alt="image-20221010180914111">

<p>这里使用的 <code>vscode</code> 的 <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a> 插件。</p>
<p>观察POST数据包的 body 部分，疑似加密，前半部分是典型的 <code>urlencode</code> + <code>Base64</code> (%30%30)解开是二进制，后半部分直接是二进制。</p>
<p><code>encSecKey</code>将成为一个突破口。</p>
<h3 id="分析加解密"><a href="#分析加解密" class="headerlink" title="分析加解密"></a>分析加解密</h3><p>打开浏览器的 开发人员工具 (F12), 全局搜索(<code>ctrl + shift + f</code>) <code>encSecKey</code>，找到全部与之相关的js，</p>
<p><code>format</code> 一下，全部下断点，实际上正常应该分析一下上下文，但是总共就 <code>3,4</code> 处，直接全断最方便了。</p>
<p>刷新网页，会断到 <code>core_xxxxxxxxxxxxx.js</code> 中名为 <code> function d(d, e, f, g)</code> 的函数，虽然名称被混淆了，<br>但是这里确实是加密。<br>当然为了验证是否是前面那个接口用到的加密，还需要往后跟到发包函数，多看几组包就能确定了。<br>这个过程我已经做了，由于篇幅问题，不再多说。</p>
<p>拓展一下，不从<code>encSecKey</code>分析也是可以的，搜 <code>csrf_token</code> 下断点，往上回溯几层，<br>你会跟到 <code>window.asrsea = d</code>，实际上拿 <code> window.asrsea</code> 去百度搜会发现有人写过类似的文章了。</p>
<p>函数很短就整个提过来了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (d = <span class="number">0</span>; a &gt; d; d += <span class="number">1</span>)</span><br><span class="line">            e = <span class="title class_">Math</span>.<span class="title function_">random</span>() * b.<span class="property">length</span>,</span><br><span class="line">            e = <span class="title class_">Math</span>.<span class="title function_">floor</span>(e),</span><br><span class="line">            c += b.<span class="title function_">charAt</span>(e);</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(b)</span><br><span class="line">          , d = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="string">&quot;0102030405060708&quot;</span>)</span><br><span class="line">          , e = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(a)</span><br><span class="line">          , f = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(e, c, &#123;</span><br><span class="line">            <span class="attr">iv</span>: d,</span><br><span class="line">            <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">toString</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> d, e;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">setMaxDigits</span>(<span class="number">131</span>),</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">RSAKeyPair</span>(b,<span class="string">&quot;&quot;</span>,c),</span><br><span class="line">        e = <span class="title function_">encryptedString</span>(d, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">d, e, f, g</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> h = &#123;&#125;</span><br><span class="line">          , i = <span class="title function_">a</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> h.<span class="property">encText</span> = <span class="title function_">b</span>(d, g),</span><br><span class="line">        h.<span class="property">encText</span> = <span class="title function_">b</span>(h.<span class="property">encText</span>, i),</span><br><span class="line">        h.<span class="property">encSecKey</span> = <span class="title function_">c</span>(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">e</span>(<span class="params">a, b, d, e</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> f = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> f.<span class="property">encText</span> = <span class="title function_">c</span>(a + e, b, d),</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">asrsea</span> = d,</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">ecnonasr</span> = e</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>逐个函数看</p>
<ul>
<li><code>function a(a)</code>，看到 <code>a-zA-Z0-9</code> 加个循环里面用 <code>rand</code>，非常典型的随机串生成算法，根据循环条件得知参数为串长度。</li>
<li><code>function b(a, b)</code>，它都说了是 <code>AES</code> 了，加密模式是 <code>CBC</code>，怕它不老实，不使用标准实现，随手找个在线加密网站，可以进行验证，测试一遍后能得到填充模式为 <code>PKCS_PADDING</code>。 参数分别是源跟密钥。</li>
<li><code>function c(a, b, c)</code>，<code>RSA</code>这个老实说不好在线验证，先放着，后面用代码验证。</li>
<li><code>function d(d, e, f, g) </code>，主加密流程，多观察几遍就会发现除了 <code>d</code> ，都是固定值，拷贝下来即可，而<code>d</code>中是个 <code>json</code>明文。</li>
<li><code>function e(a, b, d, e) </code>，看上去似乎是类似流程，不过跟本文无关。</li>
</ul>
<p>有意思的是 <code>window.asrsea</code> 的后半部分倒过来是 <code>aesrsa</code>，小彩蛋?<br><code>rsanonce</code> 对应 <code>RSA Nonce</code> 加密?</p>
<h2 id="从js到python"><a href="#从js到python" class="headerlink" title="从js到python"></a>从js到python</h2><p>最近在学习 <code>rust</code>，本来是准备练下手的，只可惜学艺不精，处处跟编译器对着干，就是那种明明知道该怎么写，但是用你就偏偏搞不定的感觉。</p>
<p>写这种小工具，还是<code>python</code> 最快了。<br>装个基础环境,<code>vscode</code>里面简单配置一下，几分钟就搞定了，顺便装一下 <code>setuptools</code> 和 <code>pip</code>，再也不用担心找不到依赖库了。<br>python 本身自带一个 <code>crypt</code> 模块，看起来有点简陋，需要重新找一个密码学库。<br>用 <code>pip search crypt</code>  能搜到一些库，但是担心版本太旧不兼容问题，网上搜了一下，说是现在用的比较多的是 <code>pycryptodome</code></p>
<p><code>pip install pycryptodome</code> 安装。</p>
<h3 id="创建文件，写一个带测试的类"><a href="#创建文件，写一个带测试的类" class="headerlink" title="创建文件，写一个带测试的类"></a>创建文件，写一个带测试的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicDecrypt</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, methodName=<span class="string">&#x27;runTest&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MusicDecrypt, <span class="variable language_">self</span>).__init__(methodName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="编写-AES-及测试方法"><a href="#编写-AES-及测试方法" class="headerlink" title="编写 AES 及测试方法"></a>编写 <code>AES</code> 及测试方法</h3><p>源算法中用 <code>AES</code> 加密了两次，第一次是固定 <code>key</code> <code>0CoJUm6Qyw8W8jud</code>，第二次是长度为16的随机串(关于这个后面细说)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 加到最上面</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># 加到 MusicDecrypt 里</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># AES</span></span><br><span class="line">    <span class="comment"># CBC</span></span><br><span class="line">    <span class="comment"># pkcs5padding</span></span><br><span class="line">    <span class="comment"># 128bit</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">self, s, k, iv=<span class="string">&quot;0102030405060708&quot;</span></span>):</span><br><span class="line">        l = <span class="number">16</span> - <span class="built_in">len</span>(s) % <span class="number">16</span></span><br><span class="line">        <span class="comment"># pkcs5padding</span></span><br><span class="line">        s += + l * <span class="built_in">chr</span>(l)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(<span class="built_in">len</span>(s) % <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(AES.new(k.encode(<span class="string">&quot;utf-8&quot;</span>), AES.MODE_CBC, iv.encode(<span class="string">&quot;utf-8&quot;</span>)).encrypt(s.encode(<span class="string">&quot;utf-8&quot;</span>))).decode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_aes_encrypt</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        enc = <span class="variable language_">self</span>.aes_encrypt(</span><br><span class="line">            s=<span class="string">&#x27;&#123;&quot;ids&quot;:&quot;[28949499]&quot;,&quot;level&quot;:&quot;standard&quot;,&quot;encodeType&quot;:&quot;aac&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>,</span><br><span class="line">            k=<span class="string">&quot;0CoJUm6Qyw8W8jud&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(</span><br><span class="line">            enc,</span><br><span class="line">            <span class="string">&quot;g1N6YybxFdV98P/fGY0407hwjh0evx5kPtxXR0nPd/WPPFsi9Lf67vFfjUnM3MDahHpqkyZMS+9goaszbHF+i1fIufNBu+8BbSvBCJSVfEU=&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(</span><br><span class="line">            <span class="variable language_">self</span>.aes_encrypt(</span><br><span class="line">                s=enc,</span><br><span class="line">                k=<span class="string">&quot;GR1dIlooUjX3zmY1&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            <span class="string">&quot;9R0jh8yE6/JTTwoH4ujCacPMOwJdbXk39BlG3ODTNe+rHMLAOSHDlp/Mza7+15lOi8bvPMtLnA6gCOujDj5iuVBJF2a2DJVkNLtrTtgl+AXpsR5hSh0+EOfuads7lq41B9EpYKktwB72zOy+kafalQ==&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p><strong>这个是之前调试js时存下来的数据，通过对这组数据测试，就能写出正确的算法， RSA 同理。</strong><br>只需要将js中的b忠实还原就行了。</p>
<h3 id="编写-RSA-及测试方法"><a href="#编写-RSA-及测试方法" class="headerlink" title="编写 RSA 及测试方法"></a>编写 <code>RSA</code> 及测试方法</h3><p>显然js中用的 RSA 并非是平常的用法，最少传进去不是个标准的公钥。</p>
<p>网上搜了一下 <code>RSA</code> 的算法解释。</p>
<ul>
<li><a href="https://www.jianshu.com/p/76a462a6911a">RSA算法逆向总结</a></li>
</ul>
<p>得知 RSA 的加密算法核心是<br><code>c = (p ^ e) mod n</code><br>方程中p表示源串，c表示加密串，n就是文件上面说的Modules，e则为Exponent，(n, e)表示PublicKey。</p>
<p>通过调试js能得到3个数据，</p>
<ol>
<li><code>GR1dIlooUjX3zmY1</code></li>
<li><code>010001</code></li>
<li><code>一段很长的数据</code></li>
</ol>
<p>根据 <code>function c(a, b, c)</code> 的算法，得知 <code>b,c</code> 构成 <code>KeyPair</code>，最后加密的是<code>a</code>，也就是 <code>GR1dIlooUjX3zmY1</code>，<code>GR1dIlooUjX3zmY1</code>本身是由 <code>function a(a)</code> 生成的16个字节(char)长度的随机串，曾作为 AES 的 key 使用过。</p>
<p>那么剩下两个对应到算法里就是 <code>e</code> 与 <code>n</code> 了。<br>其实简单看一下就明白 <code>3</code> 不可能是 <code>e</code>，当然也可以跑一下，一个这么大的幂，根本就算不出来的。<br>当然跟入 <code>js</code> 库里面看一下就清楚了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">RSAKeyPair</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">e</span> = <span class="title function_">biFromHex</span>(a),</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">d</span> = <span class="title function_">biFromHex</span>(b),</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">m</span> = <span class="title function_">biFromHex</span>(c),</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chunkSize</span> = <span class="number">2</span> * <span class="title function_">biHighIndex</span>(<span class="variable language_">this</span>.<span class="property">m</span>),</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radix</span> = <span class="number">16</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">barrett</span> = <span class="keyword">new</span> <span class="title class_">BarrettMu</span>(<span class="variable language_">this</span>.<span class="property">m</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encryptedString</span>(<span class="params">a, b</span>)&#123;<span class="comment">// 省略&#125;</span></span><br></pre></td></tr></table></figure>
<p>e 对应 <code>010001</code>， m 对应很长的串。 <code>encryptedString</code> 就是个大数算法，在运用公式前需要将 <code>GR1dIlooUjX3zmY1</code> 翻转一下。</p>
<p><strong>老实说，原<code>js</code>里面似乎并没有先翻转，整个算法研究了一下与普通的RSA算法一样，<br>疑似以某种等价的方式置入了 <code>biToHex</code> 中，具体 <code>biToHex</code> 就没有分析为什么会等价了，有兴趣可以自行研究。</strong></p>
<p>接下来就是写验证代码了，由于 python 原生支持大数，直接将 <code>GR1dIlooUjX3zmY1</code> 翻转并转成大数就行了，</p>
<p>这个在 python 里面只需要一句代码，如果不是在 python 中还会涉及大数运算问题，好在 python 原生就支持这个。</p>
<p><code>int(binascii.hexlify(p[::-1].encode(&quot;utf-8&quot;)), 16)</code></p>
<p><code>[::-1]</code> 翻转，<code>binascii.hexlify</code> 转为 <code>bytes</code> 再通过 <code>int</code>(16代表源数据是16进制) 转为大数即可。</p>
<blockquote>
<p>.b’1Ymz3XjUoolId1RG’<br>b’31596d7a33586a556f6f6c4964315247’<br>0X31596D7A33586A556F6F6C4964315247</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 加到最上面</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># 加到 MusicDecrypt 里</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># reverse p : p = p[::-1]</span></span><br><span class="line">    <span class="comment"># [p^e] % m</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rsa_encrypt</span>(<span class="params">self, p, e, m</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format</span>(<span class="built_in">int</span>(binascii.hexlify(p[::-<span class="number">1</span>].encode(<span class="string">&quot;utf-8&quot;</span>)), <span class="number">16</span>)**<span class="built_in">int</span>(e, <span class="number">16</span>) % <span class="built_in">int</span>(m, <span class="number">16</span>), <span class="string">&#x27;x&#x27;</span>).zfill(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_rsa_encrypt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(</span><br><span class="line">            <span class="variable language_">self</span>.rsa_encrypt(</span><br><span class="line">                p=<span class="string">&quot;GR1dIlooUjX3zmY1&quot;</span>,</span><br><span class="line">                e=<span class="string">&quot;010001&quot;</span>,</span><br><span class="line">                m=<span class="string">&quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            <span class="string">&quot;abc2e11cd93268085180aace6208c0caed01b7c2af641999a79adf362fb778a3fba5117f9c06541a5620d4dccd628085b53c1b22d971068a458e1ac16d831860ab2f1da4c7c8342f8bb815c6ab6c6c335cc797a4273124ff4846c9d58b0015691f933323fe080b8d026836880af99e918c7ace1813356b8bc327a52dcc24050a&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h3 id="构造body"><a href="#构造body" class="headerlink" title="构造body"></a>构造body</h3><p>将两次<code>AES</code>之后 的结果进行 <code>urlencode</code> ，然后与RSA的返回值拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 加在最前面</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">    randKey = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 替换 __init__</span></span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">__init__</span>(<span class="params">self, methodName=<span class="string">&#x27;runTest&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MusicDecrypt, <span class="variable language_">self</span>).__init__(methodName)</span><br><span class="line">        <span class="variable language_">self</span>.randKey = <span class="string">&#x27;&#x27;</span>.join(random.sample(</span><br><span class="line">            string.ascii_letters + string.digits, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 加入 MusicDecrypt</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">packet_body</span>(<span class="params">self, <span class="built_in">id</span></span>):</span><br><span class="line">        enc_text = <span class="variable language_">self</span>.aes_encrypt(</span><br><span class="line">            s=<span class="string">&#x27;&#123;&quot;ids&quot;:&quot;[&#x27;</span> + <span class="built_in">id</span> + <span class="string">&#x27;]&quot;,&quot;level&quot;:&quot;standard&quot;,&quot;encodeType&quot;:&quot;mp3&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>,</span><br><span class="line">            k=<span class="string">&quot;0CoJUm6Qyw8W8jud&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        enc_text = <span class="variable language_">self</span>.aes_encrypt(</span><br><span class="line">            s=enc_text,</span><br><span class="line">            k=<span class="variable language_">self</span>.randKey,</span><br><span class="line">        )</span><br><span class="line">        enc_sec_key = <span class="variable language_">self</span>.rsa_encrypt(</span><br><span class="line">            p=<span class="variable language_">self</span>.randKey,</span><br><span class="line">            e=<span class="string">&quot;010001&quot;</span>,</span><br><span class="line">            m=<span class="string">&quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;params=&#x27;</span> + urllib.parse.quote(enc_text) +</span><br><span class="line">                <span class="string">&#x27;&amp;encSecKey=&#x27;</span> + enc_sec_key)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单整理之后，在 main 中调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># unittest.main()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(MusicDecrypt()</span><br><span class="line">          .packet_body(<span class="string">&#x27;1297747757&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>将得到的数据放入 REST-Client 测试是否正常返回。依据这种思路，还能得到图片和歌词的地址，另外中间的参数也可以配置,<br>例如 encodeType 可以调整为 aac 等。</p>
<p>python版在这里就算告一段落了。</p>
<h2 id="从js到c"><a href="#从js到c" class="headerlink" title="从js到c++"></a>从js到c++</h2><h3 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h3><p>作为微软官方的c++包管理工具，虽然并不是很好用，但总比没有强。</p>
<p>1.安装 <code>vs</code>，本文用的 <code>vs2019</code><br>2.安装 <code>vcpkg</code>，很容易，命令行跑一下就行了</p>
<p>看一下基本命令</p>
<ul>
<li><code>search</code></li>
<li><code>install --triplet</code> &#x2F; <code>install xxx:x64-windows</code></li>
</ul>
<p>例如 安装 boost 库, <code>:</code> 后面代表的是 x64 的动态库<br><code>vcpkg install boost:x64-windows</code><br>可以随便输入一个错误信息，它会提示有哪些版本<br><code>vcpkg install boost:x</code></p>
<blockquote>
<p>  x64-windows<br>  x64-windows-static<br>  x86-windows<br>  x86-windows-static</p>
</blockquote>
<p><code>windows</code> 上开发，大概也就这几个用的比较多了。</p>
<h3 id="cryptopp-与-cpr"><a href="#cryptopp-与-cpr" class="headerlink" title="cryptopp 与 cpr"></a>cryptopp 与 cpr</h3><p>本文的加密库选的 <code>cryptopp</code>，事实上我对<code>c</code>版的 <code>libsodium</code> <code>openssl</code>，只是我考虑像 <code>python</code> 那样简洁的实现，所以语言上选的 <code>c++</code>，既然用 <code>c++</code> 还是统一比较好。</p>
<p>另外本文选了 <code>boost.test</code> 做单元测试，偷懒的话可以不测试。</p>
<p><code>cryptopp</code>开始用的时候还是有点不习惯。对着手册总算是翻完了。</p>
<p><strong>本文为了行文方便，直接全都塞到了头文件，实际开发中应该分开，避免头文件互相引用导致重定义等问题。</strong></p>
<h3 id="编写加解密逻辑"><a href="#编写加解密逻辑" class="headerlink" title="编写加解密逻辑"></a>编写加解密逻辑</h3><p>c++部分就从简了，毕竟分析过一次实现逻辑了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/cryptlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/modes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/aes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/randpool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/osrng.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/base64.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cryptopp/hex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cpr/util.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> music&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicDecrypt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MusicDecrypt</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造 e</span></span><br><span class="line">        std::<span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">uint32_t</span>&gt;(std::<span class="built_in">time</span>(<span class="literal">nullptr</span>)));</span><br><span class="line">        <span class="keyword">for</span> (std::<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            rsa_p.<span class="built_in">push_back</span>(original_seq[<span class="built_in">rand</span>() % original_seq.<span class="built_in">length</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">MusicDecrypt</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">aes_encrypt</span><span class="params">(std::string s, std::string k = <span class="string">&quot;0CoJUm6Qyw8W8jud&quot;</span>, std::string iv = <span class="string">&quot;0102030405060708&quot;</span>)</span> </span>&#123;</span><br><span class="line">        std::string cipher_text;</span><br><span class="line"></span><br><span class="line">        CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::<span class="function">Encryption <span class="title">cbc_enc</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> std::<span class="type">uint8_t</span>*&gt;(k.data()), k.length(), <span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> std::<span class="type">uint8_t</span>*&gt;(iv.data()))</span></span>;</span><br><span class="line"></span><br><span class="line">        CryptoPP::StringSource _(s, <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">new</span> CryptoPP::<span class="built_in">StreamTransformationFilter</span>(</span><br><span class="line">            cbc_enc,                                              <span class="comment">// cbc 编码</span></span><br><span class="line">            <span class="keyword">new</span> CryptoPP::<span class="built_in">Base64Encoder</span>(                          <span class="comment">// base64解码 参数2置为false表示不换行</span></span><br><span class="line">                <span class="keyword">new</span> CryptoPP::<span class="built_in">StringSink</span>(cipher_text),<span class="literal">false</span>),     <span class="comment">// 不需要 delete, 里面包装了 https://www.cryptopp.com/wiki/StringSource</span></span><br><span class="line">            CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING)        <span class="comment">// PKCS_PADDING 填充</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> cipher_text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">rsa_encrypt</span><span class="params">(std::string p, std::string e = <span class="string">&quot;&quot;</span>, std::string m = <span class="string">&quot;&quot;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="built_in">empty</span>())</span><br><span class="line">            e = default_e;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">            m = default_m;</span><br><span class="line"></span><br><span class="line">        std::string ps = <span class="string">&quot;0x&quot;</span>;</span><br><span class="line">        std::<span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">        CryptoPP::StringSource _(p, <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">new</span> CryptoPP::<span class="built_in">HexEncoder</span>(</span><br><span class="line">                <span class="keyword">new</span> CryptoPP::<span class="built_in">StringSink</span>(ps),</span><br><span class="line">                <span class="literal">true</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;0x&quot;</span></span><br><span class="line">            ) <span class="comment">// HexEncoder</span></span><br><span class="line">        ); <span class="comment">// StringSource</span></span><br><span class="line"></span><br><span class="line">        <span class="function">CryptoPP::Integer <span class="title">ni</span><span class="params">(m.c_str())</span>, <span class="title">ei</span><span class="params">(e.c_str())</span>, <span class="title">pi</span><span class="params">(ps.c_str())</span></span>;</span><br><span class="line"></span><br><span class="line">        CryptoPP::RSA::PublicKey pubKey;</span><br><span class="line">        pubKey.<span class="built_in">Initialize</span>(ni, ei);</span><br><span class="line"></span><br><span class="line">        <span class="function">CryptoPP::RSAES_OAEP_SHA_Encryptor <span class="title">pub</span><span class="params">(pubKey)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CryptoPP::<span class="built_in">IntToString</span>(pubKey.<span class="built_in">ApplyFunction</span>(pi), <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">paket_body</span><span class="params">(std::string id, std::string k = <span class="string">&quot;&quot;</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> enc_text = <span class="string">u8&quot;&#123;\&quot;ids\&quot;:\&quot;[&quot;</span> +</span><br><span class="line">            id +</span><br><span class="line">            <span class="string">&quot;]\&quot;,\&quot;level\&quot;:\&quot;standard\&quot;,\&quot;encodeType\&quot;:\&quot;mp3\&quot;,\&quot;csrf_token\&quot;:\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!k.<span class="built_in">empty</span>())</span><br><span class="line">            rsa_p = k;</span><br><span class="line"></span><br><span class="line">        enc_text = <span class="built_in">aes_encrypt</span>(enc_text);</span><br><span class="line">        enc_text = <span class="built_in">aes_encrypt</span>(enc_text, rsa_p);</span><br><span class="line">        <span class="keyword">auto</span> enc_sec_key = <span class="built_in">rsa_encrypt</span>(rsa_p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;params=&quot;</span> + cpr::util::<span class="built_in">urlEncode</span>(enc_text) +</span><br><span class="line">            <span class="string">&quot;&amp;encSecKey=&quot;</span> + enc_sec_key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string rsa_p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字符序列</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string original_seq;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string default_e;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string default_m;</span><br><span class="line">&#125;; <span class="comment">// MusicDecrypt</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string MusicDecrypt::original_seq = <span class="string">u8&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string MusicDecrypt::default_e = <span class="string">u8&quot;0x010001&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string MusicDecrypt::default_m = <span class="string">u8&quot;0x00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// music</span></span><br></pre></td></tr></table></figure>

<h3 id="编写网络模块"><a href="#编写网络模块" class="headerlink" title="编写网络模块"></a>编写网络模块</h3><p><code>cpr</code> 的使用就比较简单了，和 <code>python</code> 的 <code>urllib</code> 有的一比。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cpr/cpr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> music &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicJson</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MusicJson</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MusicJson</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get_json</span><span class="params">(std::string packet_body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> r = cpr::<span class="built_in">Post</span>(cpr::Url&#123; <span class="string">&quot;https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=&quot;</span> &#125;,</span><br><span class="line">            cpr::Body&#123; packet_body &#125;,</span><br><span class="line">            cpr::Header&#123; &#123;<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>&#125;,&#123;<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  r.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// MusicJson</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// music</span></span><br></pre></td></tr></table></figure>

<h3 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h3><p>需要注意，测试和上面的编写实际上是同步进行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _TEST_MODULE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOST_TEST_MODULE music_test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/test/included/unit_test.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/log/trivial.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;music_decrypt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;music_get_json.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局测试夹具</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">global_fixture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">global_fixture</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开始准备测试数据-------&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span>~<span class="built_in">global_fixture</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;清理测试环境&lt;---------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_GLOBAL_FIXTURE</span>(global_fixture);</span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase_4_aes_encrypt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> enc_text = music::<span class="built_in">MusicDecrypt</span>().<span class="built_in">aes_encrypt</span>(<span class="string">u8&quot;&#123;\&quot;ids\&quot;:\&quot;[28949499]\&quot;,\&quot;level\&quot;:\&quot;standard\&quot;,\&quot;encodeType\&quot;:\&quot;aac\&quot;,\&quot;csrf_token\&quot;:\&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;开始测试 aes_encrypt&quot;</span>;</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(enc_text == <span class="string">&quot;g1N6YybxFdV98P/fGY0407hwjh0evx5kPtxXR0nPd/WPPFsi9Lf67vFfjUnM3MDahHpqkyZMS+9goaszbHF+i1fIufNBu+8BbSvBCJSVfEU=&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(music::<span class="built_in">MusicDecrypt</span>().<span class="built_in">aes_encrypt</span>(enc_text, <span class="string">u8&quot;GR1dIlooUjX3zmY1&quot;</span>) ==</span><br><span class="line">        <span class="string">&quot;9R0jh8yE6/JTTwoH4ujCacPMOwJdbXk39BlG3ODTNe+rHMLAOSHDlp/Mza7+15lOi8bvPMtLnA6gCOujDj5iuVBJF2a2DJVkNLtrTtgl+AXpsR5hSh0+EOfuads7lq41B9EpYKktwB72zOy+kafalQ==&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;结束测试 aes_encrypt&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase_4_rsa_encrypt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;开始测试 rsa_encrypt&quot;</span>;</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(music::<span class="built_in">MusicDecrypt</span>().<span class="built_in">rsa_encrypt</span>(<span class="string">u8&quot;GR1dIlooUjX3zmY1&quot;</span>) ==</span><br><span class="line">        <span class="string">&quot;abc2e11cd93268085180aace6208c0caed01b7c2af641999a79adf362fb778a3fba5117f9c06541a5620d4dccd628085b53c1b22d971068a458e1ac16d831860ab2f1da4c7c8342f8bb815c6ab6c6c335cc797a4273124ff4846c9d58b0015691f933323fe080b8d026836880af99e918c7ace1813356b8bc327a52dcc24050a&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;结束测试 rsa_encrypt&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase_4_paket_body)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;开始测试 paket_body&quot;</span>;</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(music::<span class="built_in">MusicDecrypt</span>().<span class="built_in">paket_body</span>(<span class="string">u8&quot;28949499&quot;</span>, <span class="string">u8&quot;GR1dIlooUjX3zmY1&quot;</span>) ==</span><br><span class="line">        <span class="string">&quot;params=9R0jh8yE6%2fJTTwoH4ujCacPMOwJdbXk39BlG3ODTNe%2brHMLAOSHDlp%2fMza7%2b15lOi8bvPMtLnA6gCOujDj5iuT1EbsfNRzJrzZm6oIqgWhVsWcO%2bhrLFCHDHgyIYGdXOBmuWBRRiDCyMUFJAq3yrVw%3d%3d&amp;encSecKey=abc2e11cd93268085180aace6208c0caed01b7c2af641999a79adf362fb778a3fba5117f9c06541a5620d4dccd628085b53c1b22d971068a458e1ac16d831860ab2f1da4c7c8342f8bb815c6ab6c6c335cc797a4273124ff4846c9d58b0015691f933323fe080b8d026836880af99e918c7ace1813356b8bc327a52dcc24050a&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;结束测试 paket_body&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase_4_get_json)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;开始测试 get_json&quot;</span>;</span><br><span class="line">    <span class="built_in">BOOST_TEST</span>(music::<span class="built_in">MusicJson</span>().<span class="built_in">get_json</span>(</span><br><span class="line">        <span class="string">&quot;params=9R0jh8yE6%2fJTTwoH4ujCacPMOwJdbXk39BlG3ODTNe%2brHMLAOSHDlp%2fMza7%2b15lOi8bvPMtLnA6gCOujDj5iuT1EbsfNRzJrzZm6oIqgWhVsWcO%2bhrLFCHDHgyIYGdXOBmuWBRRiDCyMUFJAq3yrVw%3d%3d&amp;encSecKey=abc2e11cd93268085180aace6208c0caed01b7c2af641999a79adf362fb778a3fba5117f9c06541a5620d4dccd628085b53c1b22d971068a458e1ac16d831860ab2f1da4c7c8342f8bb815c6ab6c6c335cc797a4273124ff4846c9d58b0015691f933323fe080b8d026836880af99e918c7ace1813356b8bc327a52dcc24050a&quot;</span></span><br><span class="line">    ) != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">BOOST_LOG_TRIVIAL</span>(info) &lt;&lt; <span class="string">&quot;结束测试 get_json&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="main-和-config"><a href="#main-和-config" class="headerlink" title="main 和 config"></a>main 和 config</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !_TEST_MODULE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;music_decrypt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;music_get_json.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DEBUG_EXPR</span>(std::cout &lt;&lt; music::<span class="built_in">MusicJson</span>().<span class="built_in">get_json</span>(music::<span class="built_in">MusicDecrypt</span>().<span class="built_in">paket_body</span>(<span class="string">&quot;31830011&quot;</span>)) &lt;&lt; std::endl;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _TEST</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_MODULE 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EXPR(x) do&#123;x&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_EXPR(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><img src="/2020/01/10/yun_music_cryptor/image-20221010181116980.png" class="" alt="image-20221010181116980">

<p>该版本代码仅仅是个<code>Demo</code>，可以考虑 <code>enum</code> + <code>map</code> 支持一下获取歌词图片啥的，再引入json解析库做个下载器啥的。</p>
<h3 id="趟坑-cpp-netlib"><a href="#趟坑-cpp-netlib" class="headerlink" title="趟坑 cpp-netlib"></a>趟坑 cpp-netlib</h3><p>开始用的 <code>cpp-netlib</code>，毕竟支持同时客户端服务端，直到我的膝盖中了一箭。</p>
<p><code>vcpkg</code> 默认当前安装的是 <code>boost 1.7.0 +</code> 版本，<br>当前的 <code>cpp-netlib 1.3.0</code> 只能用 <code>boost 1.6.9</code> 以下版本，具体哪个版本我也没翻到。</p>
<p>Error:</p>
<ol>
<li><code>error C3536: &quot;delegate&quot; 未初始化</code> – <a href="https://github.com/boostorg/proto/pull/2/files">bugfix</a></li>
<li><code>error: no member named &#39;get_io_service&#39;</code> – <a href="https://github.com/rstudio/rstudio/issues/4636">issues_4636</a></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文算是个大杂烩，从各方面讲了一通，算是为以后有移到php需求的时候打个底。 :D</p>
]]></content>
      <tags>
        <tag>protocol_analysis</tag>
      </tags>
  </entry>
</search>
